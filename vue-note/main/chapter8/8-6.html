<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>8.6 导航守卫（中） | 卷心菜笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./logo.jpg">
    <meta name="description" content="基于vue@2.6.14的学习笔记">
    
    <link rel="preload" href="./assets/css/0.styles.74c59701.css" as="style"><link rel="preload" href="./assets/js/app.20317d9d.js" as="script"><link rel="preload" href="./assets/js/2.8a65079d.js" as="script"><link rel="preload" href="./assets/js/14.96a92186.js" as="script"><link rel="prefetch" href="./assets/js/10.3d2f32ec.js"><link rel="prefetch" href="./assets/js/11.132a26b4.js"><link rel="prefetch" href="./assets/js/12.d0193009.js"><link rel="prefetch" href="./assets/js/13.07872830.js"><link rel="prefetch" href="./assets/js/15.89c1bf18.js"><link rel="prefetch" href="./assets/js/16.78f7cadf.js"><link rel="prefetch" href="./assets/js/17.eee5b860.js"><link rel="prefetch" href="./assets/js/18.e94d03e8.js"><link rel="prefetch" href="./assets/js/19.9e73c1ac.js"><link rel="prefetch" href="./assets/js/20.ae18bc8e.js"><link rel="prefetch" href="./assets/js/21.d4a5ba0b.js"><link rel="prefetch" href="./assets/js/22.e7794d4a.js"><link rel="prefetch" href="./assets/js/23.adaee962.js"><link rel="prefetch" href="./assets/js/24.e1df98bf.js"><link rel="prefetch" href="./assets/js/25.c325e810.js"><link rel="prefetch" href="./assets/js/26.c24daaf7.js"><link rel="prefetch" href="./assets/js/27.a3f09949.js"><link rel="prefetch" href="./assets/js/28.123d6383.js"><link rel="prefetch" href="./assets/js/29.04a6e255.js"><link rel="prefetch" href="./assets/js/3.5a34bef2.js"><link rel="prefetch" href="./assets/js/30.f976c0a7.js"><link rel="prefetch" href="./assets/js/31.60d2f4c4.js"><link rel="prefetch" href="./assets/js/32.6b2a5515.js"><link rel="prefetch" href="./assets/js/33.6b80e89d.js"><link rel="prefetch" href="./assets/js/34.ea39628f.js"><link rel="prefetch" href="./assets/js/35.4c14bc3d.js"><link rel="prefetch" href="./assets/js/36.5f2b7559.js"><link rel="prefetch" href="./assets/js/37.57e976da.js"><link rel="prefetch" href="./assets/js/38.191568b8.js"><link rel="prefetch" href="./assets/js/39.f89500e6.js"><link rel="prefetch" href="./assets/js/4.9fb18247.js"><link rel="prefetch" href="./assets/js/40.a45a4a21.js"><link rel="prefetch" href="./assets/js/41.94ece143.js"><link rel="prefetch" href="./assets/js/42.224304d2.js"><link rel="prefetch" href="./assets/js/43.544241cd.js"><link rel="prefetch" href="./assets/js/44.6014c885.js"><link rel="prefetch" href="./assets/js/45.711ad2c3.js"><link rel="prefetch" href="./assets/js/46.19b76064.js"><link rel="prefetch" href="./assets/js/47.0a8f7a4f.js"><link rel="prefetch" href="./assets/js/48.da28ae74.js"><link rel="prefetch" href="./assets/js/49.97615384.js"><link rel="prefetch" href="./assets/js/5.0c239c66.js"><link rel="prefetch" href="./assets/js/50.06bd69e2.js"><link rel="prefetch" href="./assets/js/51.ea943f69.js"><link rel="prefetch" href="./assets/js/52.b4813218.js"><link rel="prefetch" href="./assets/js/53.c1ba1696.js"><link rel="prefetch" href="./assets/js/54.e1d1801c.js"><link rel="prefetch" href="./assets/js/55.ac7cd0ab.js"><link rel="prefetch" href="./assets/js/56.d55c7dcb.js"><link rel="prefetch" href="./assets/js/57.83bbfc8e.js"><link rel="prefetch" href="./assets/js/58.6996ec46.js"><link rel="prefetch" href="./assets/js/59.42c770e8.js"><link rel="prefetch" href="./assets/js/6.0600552c.js"><link rel="prefetch" href="./assets/js/60.919088d2.js"><link rel="prefetch" href="./assets/js/61.455d2404.js"><link rel="prefetch" href="./assets/js/62.40ba97a6.js"><link rel="prefetch" href="./assets/js/63.5b069dba.js"><link rel="prefetch" href="./assets/js/64.512e158a.js"><link rel="prefetch" href="./assets/js/65.6ca1c75b.js"><link rel="prefetch" href="./assets/js/66.0356130d.js"><link rel="prefetch" href="./assets/js/67.93a0d7df.js"><link rel="prefetch" href="./assets/js/68.7e44cc19.js"><link rel="prefetch" href="./assets/js/69.788a4d27.js"><link rel="prefetch" href="./assets/js/7.6346a45d.js"><link rel="prefetch" href="./assets/js/70.571f8a79.js"><link rel="prefetch" href="./assets/js/71.f54eb805.js"><link rel="prefetch" href="./assets/js/72.02cd77d0.js"><link rel="prefetch" href="./assets/js/73.66b6b1d0.js"><link rel="prefetch" href="./assets/js/74.96bf5acc.js"><link rel="prefetch" href="./assets/js/75.1b135bdd.js"><link rel="prefetch" href="./assets/js/76.6ed173f1.js"><link rel="prefetch" href="./assets/js/77.ee856c8d.js"><link rel="prefetch" href="./assets/js/78.b8fc2c30.js"><link rel="prefetch" href="./assets/js/79.7665732d.js"><link rel="prefetch" href="./assets/js/8.6ff51652.js"><link rel="prefetch" href="./assets/js/80.03e59e67.js"><link rel="prefetch" href="./assets/js/81.a6236c2f.js"><link rel="prefetch" href="./assets/js/82.88a5092b.js"><link rel="prefetch" href="./assets/js/83.e93ce178.js"><link rel="prefetch" href="./assets/js/84.8eb37a19.js"><link rel="prefetch" href="./assets/js/85.9d8d91db.js"><link rel="prefetch" href="./assets/js/86.14696351.js"><link rel="prefetch" href="./assets/js/87.51a4cddc.js"><link rel="prefetch" href="./assets/js/88.5cb86311.js"><link rel="prefetch" href="./assets/js/89.11fe5589.js"><link rel="prefetch" href="./assets/js/9.aaa202b7.js"><link rel="prefetch" href="./assets/js/90.b3555572.js">
    <link rel="stylesheet" href="./assets/css/0.styles.74c59701.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">卷心菜笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/./main/" aria-current="page" class="sidebar-link">前言</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 初识Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter1/1-1.html" class="sidebar-link">1.1 Vue目录设计</a></li><li><a href="/./main/chapter1/1-2.html" class="sidebar-link">1.2 Vue入口文件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 Vue初始化和挂载</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter2/2-1.html" class="sidebar-link">2.1 new Vue()时做了什么</a></li><li><a href="/./main/chapter2/2-2.html" class="sidebar-link">2.2 Vue实例挂载的实现</a></li><li><a href="/./main/chapter2/2-3.html" class="sidebar-link">2.3 Vue挂载时的mountComponent</a></li><li><a href="/./main/chapter2/2-4.html" class="sidebar-link">2.4 Virtual DOM</a></li><li><a href="/./main/chapter2/2-5.html" class="sidebar-link">2.5 最终的挂载方法_update</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第三章 组件化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter3/3-1.html" class="sidebar-link">3.1 创建组件vnode</a></li><li><a href="/./main/chapter3/3-2.html" class="sidebar-link">3.2 组件的patch过程</a></li><li><a href="/./main/chapter3/3-3.html" class="sidebar-link">3.3 合并配置</a></li><li><a href="/./main/chapter3/3-4.html" class="sidebar-link">3.4 生命周期（上）</a></li><li><a href="/./main/chapter3/3-5.html" class="sidebar-link">3.5 生命周期（下）</a></li><li><a href="/./main/chapter3/3-6.html" class="sidebar-link">3.6 组件的注册</a></li><li><a href="/./main/chapter3/3-7.html" class="sidebar-link">3.7 异步组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第四章 响应式原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter4/4-1.html" class="sidebar-link">4.1 响应式对象</a></li><li><a href="/./main/chapter4/4-2.html" class="sidebar-link">4.2 依赖收集（上）</a></li><li><a href="/./main/chapter4/4-3.html" class="sidebar-link">4.3 依赖收集（下）</a></li><li><a href="/./main/chapter4/4-4.html" class="sidebar-link">4.4 派发更新</a></li><li><a href="/./main/chapter4/4-5.html" class="sidebar-link">4.5 nextTick</a></li><li><a href="/./main/chapter4/4-6.html" class="sidebar-link">4.6 检测变化的坑</a></li><li><a href="/./main/chapter4/4-7.html" class="sidebar-link">4.7 计算属性</a></li><li><a href="/./main/chapter4/4-8.html" class="sidebar-link">4.8 侦听器</a></li><li><a href="/./main/chapter4/4-9.html" class="sidebar-link">4.9 组件更新</a></li><li><a href="/./main/chapter4/4-10.html" class="sidebar-link">4.10 diff算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter5/5-1.html" class="sidebar-link">5.1 初探编译器</a></li><li><a href="/./main/chapter5/5-2.html" class="sidebar-link">5.2 从入口开始</a></li><li><a href="/./main/chapter5/5-3.html" class="sidebar-link">5.3 parse之解析模板（上）</a></li><li><a href="/./main/chapter5/5-4.html" class="sidebar-link">5.4 parse之解析模板（下）</a></li><li><a href="/./main/chapter5/5-5.html" class="sidebar-link">5.5 parse之生成AST（1）</a></li><li><a href="/./main/chapter5/5-6.html" class="sidebar-link">5.6 parse之生成AST（2）</a></li><li><a href="/./main/chapter5/5-7.html" class="sidebar-link">5.7 parse之生成AST（3）</a></li><li><a href="/./main/chapter5/5-8.html" class="sidebar-link">5.8 parse之生成AST（4）</a></li><li><a href="/./main/chapter5/5-9.html" class="sidebar-link">5.9 parse之生成AST（5）</a></li><li><a href="/./main/chapter5/5-10.html" class="sidebar-link">5.10 optimize优化</a></li><li><a href="/./main/chapter5/5-11.html" class="sidebar-link">5.11 generate代码生成（1）</a></li><li><a href="/./main/chapter5/5-12.html" class="sidebar-link">5.12 generate代码生成（2）</a></li><li><a href="/./main/chapter5/5-13.html" class="sidebar-link">5.13 generate代码生成（3）</a></li><li><a href="/./main/chapter5/5-14.html" class="sidebar-link">5.14 generate代码生成（4）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter6/6-1.html" class="sidebar-link">6.1 events（1）</a></li><li><a href="/./main/chapter6/6-2.html" class="sidebar-link">6.2 events（2）</a></li><li><a href="/./main/chapter6/6-3.html" class="sidebar-link">6.3 events（3）</a></li><li><a href="/./main/chapter6/6-4.html" class="sidebar-link">6.4 events（4）</a></li><li><a href="/./main/chapter6/6-5.html" class="sidebar-link">6.5 v-model（1）</a></li><li><a href="/./main/chapter6/6-6.html" class="sidebar-link">6.6 v-model（2）</a></li><li><a href="/./main/chapter6/6-7.html" class="sidebar-link">6.7 v-model（3）</a></li><li><a href="/./main/chapter6/6-8.html" class="sidebar-link">6.8 v-model（4）</a></li><li><a href="/./main/chapter6/6-9.html" class="sidebar-link">6.9 slot（上）</a></li><li><a href="/./main/chapter6/6-10.html" class="sidebar-link">6.10 slot（中）</a></li><li><a href="/./main/chapter6/6-11.html" class="sidebar-link">6.11 slot（下）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 内置组件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter7/7-1.html" class="sidebar-link">7.1 keep-alive（上）</a></li><li><a href="/./main/chapter7/7-2.html" class="sidebar-link">7.2 keep-alive（下）</a></li><li><a href="/./main/chapter7/7-3.html" class="sidebar-link">7.3 transition（上）</a></li><li><a href="/./main/chapter7/7-4.html" class="sidebar-link">7.4 transition（中）</a></li><li><a href="/./main/chapter7/7-5.html" class="sidebar-link">7.5 transition（下）</a></li><li><a href="/./main/chapter7/7-6.html" class="sidebar-link">7.6 transition-group</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第八章 Vue-router</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter8/8-1.html" class="sidebar-link">8.1 vue-router的注册</a></li><li><a href="/./main/chapter8/8-2.html" class="sidebar-link">8.2 VueRouter实例化</a></li><li><a href="/./main/chapter8/8-3.html" class="sidebar-link">8.3 动态路由</a></li><li><a href="/./main/chapter8/8-4.html" class="sidebar-link">8.4 match</a></li><li><a href="/./main/chapter8/8-5.html" class="sidebar-link">8.5 导航守卫（上）</a></li><li><a href="/./main/chapter8/8-6.html" aria-current="page" class="active sidebar-link">8.6 导航守卫（中）</a></li><li><a href="/./main/chapter8/8-7.html" class="sidebar-link">8.7 导航守卫（下）</a></li><li><a href="/./main/chapter8/8-8.html" class="sidebar-link">8.8 路径切换</a></li><li><a href="/./main/chapter8/8-9.html" class="sidebar-link">8.9 router-view组件</a></li><li><a href="/./main/chapter8/8-10.html" class="sidebar-link">8.10 router-link组件</a></li><li><a href="/./main/chapter8/8-11.html" class="sidebar-link">8.11 history模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_8-6-导航守卫-中"><a href="#_8-6-导航守卫-中" class="header-anchor">#</a> 8.6 导航守卫（中）</h1> <p>  上小节讲了<code>runQueue</code>方法的一部分内容，同时也留下了一些问题。我们猜测<code>queue</code>数组中存放的是导航守卫，那到底是不是正确的呢？如果是正确的那导航守卫又是怎么设计的呢？这是我们这小节要解决的内容。<br>
我们先来看一下完整导航解析流程：</p> <ol><li>导航被触发。</li> <li>在失活的组件里调用 beforeRouteLeave 守卫。</li> <li>调用全局的 beforeEach 守卫。</li> <li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li> <li>在路由配置里调用 beforeEnter。</li> <li>解析异步路由组件。</li> <li>在被激活的组件里调用 beforeRouteEnter。</li> <li>调用全局的 beforeResolve 守卫(2.5+)。</li> <li>导航被确认。</li> <li>调用全局的 afterEach 钩子。</li> <li>触发 DOM 更新。</li> <li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol> <p>首先导航触发也就是执行了我们<code>transitionTo</code>方法，然后我们来看<code>queue</code>的定义：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> <span class="token literal-property property">queue</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token operator">?</span>NavigationGuard<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>
    <span class="token comment">// in-component leave guards</span>
    <span class="token function">extractLeaveGuards</span><span class="token punctuation">(</span>deactivated<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// global before hooks</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>router<span class="token punctuation">.</span>beforeHooks<span class="token punctuation">,</span>
    <span class="token comment">// in-component update hooks</span>
    <span class="token function">extractUpdateHooks</span><span class="token punctuation">(</span>updated<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// in-config enter guards</span>
    activated<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">m</span> <span class="token operator">=&gt;</span> m<span class="token punctuation">.</span>beforeEnter<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// async components</span>
    <span class="token function">resolveAsyncComponents</span><span class="token punctuation">(</span>activated<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
</code></pre></div><p>  再来看<code>extractLeaveGuards</code>方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">extractLeaveGuards</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">deactivated</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>RouteRecord<span class="token operator">&gt;</span></span><span class="token punctuation">)</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token operator">?</span>Function<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">extractGuards</span><span class="token punctuation">(</span>deactivated<span class="token punctuation">,</span> <span class="token string">'beforeRouteLeave'</span><span class="token punctuation">,</span> bindGuard<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  deactivated前面已经说过了，是失活的路由<code>record</code>组成的数组。这个方法从名称可以看出就是提取离开守卫的方法。然后它执行一个提取守卫的方法<code>extractGuards</code>，第一个参数就是<code>deactivated</code>，第二个参数则是守卫名称，第三个参数<code>bindGuard</code>，第四个参数是布尔值<code>true</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bindGuard</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">guard</span><span class="token operator">:</span> NavigationGuard<span class="token punctuation">,</span> <span class="token literal-property property">instance</span><span class="token operator">:</span> <span class="token operator">?</span>_Vue</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>NavigationGuard <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">boundRouteGuard</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">guard</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  bindGuard是一个闭包函数，当第二个参数<code>instance</code>存在时就返回一个内存函数，内存函数会调用<code>guard</code>守卫方便，并且将<code>this</code>绑定为传入的组件<code>instance</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">extractGuards</span> <span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">records</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>RouteRecord<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
  <span class="token literal-property property">bind</span><span class="token operator">:</span> Function<span class="token punctuation">,</span>
  reverse<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token operator">?</span>Function<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> guards <span class="token operator">=</span> <span class="token function">flatMapComponents</span><span class="token punctuation">(</span>records<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">def<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> match<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> guard <span class="token operator">=</span> <span class="token function">extractGuard</span><span class="token punctuation">(</span>def<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>guard<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>guard<span class="token punctuation">)</span>
        <span class="token operator">?</span> guard<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">guard</span> <span class="token operator">=&gt;</span> <span class="token function">bind</span><span class="token punctuation">(</span>guard<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> match<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">bind</span><span class="token punctuation">(</span>guard<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> match<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token function">flatten</span><span class="token punctuation">(</span>reverse <span class="token operator">?</span> guards<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> guards<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  然后看<code>extractGuards</code>方法，可以看到第四个参数是<code>reverse</code>，首先定义了<code>guards</code>，它是一个数组，如果<code>reverse</code>为<code>true</code>则要反转<code>guards</code>数组。这里的<code>flatten</code>是一个扁平化数组方法的定义，可以处理一个二维数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">flatten</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">arr</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  guards是由<code>flatMapComponents</code>方法得到的。这里传入了<code>records</code>和一个函数。这个函数又定义了<code>guard</code>，并且它是由<code>extractGuard</code>方法得到的，这里传入<code>def</code>和<code>name</code>两个参数，<code>name</code>是守卫名称，这里是上面传入的<code>beforeRouteLeave</code>，如果<code>guard</code>存在并且是一个数组那就通过<code>map</code>遍历并返回<code>bing()</code>执行结果，否则直接返回<code>bind()</code>。这里的<code>bind</code>就是上面的<code>bindGuard</code>，它返回的是内层函数。实际上<code>bindGuard</code>就是原生的<code>bind</code>方法的模拟实现。（直接用bind方法不好吗？奇奇怪怪的——来自菜鸡作者的吐槽）<br>
  下面来看<code>flatMapComponents</code>方法的实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">flatMapComponents</span> <span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">matched</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>RouteRecord<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">fn</span><span class="token operator">:</span> Function</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token operator">?</span>Function<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">flatten</span><span class="token punctuation">(</span>matched<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">m</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>components<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span>
      m<span class="token punctuation">.</span>components<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
      m<span class="token punctuation">.</span>instances<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
      m<span class="token punctuation">,</span> key
    <span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这个方法第一个参数其实<code>records</code>，当然这里处理的失活的路由<code>record</code>，这里通过<code>map</code>去遍历<code>record</code>数组，然后把<code>record.components</code>对象的<code>keys</code>取到再次遍历，这里遍历执行的函数<code>fn</code>就是上面定义的匿名函数，最后它返回的一个<code>bind</code>返回的内层函数或者由内层函数组成的数组。这里<code>fn</code>第一个参数就是<code>components</code>的<code>key</code>所对应的组件。第二个则是<code>Vue</code>实例，这个东西我们之后遇到再分析。第三个参数是当前遍历到的<code>record</code>，最后一个则是<code>components</code>遍历对应的<code>key</code>。<br>
  这里我们来分析一下<code>components</code>，在<code>addRouteRecord</code>方法中创建了这样一个<code>record</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> <span class="token literal-property property">record</span><span class="token operator">:</span> RouteRecord <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> normalizedPath<span class="token punctuation">,</span>
    <span class="token literal-property property">regex</span><span class="token operator">:</span> <span class="token function">compileRouteRegex</span><span class="token punctuation">(</span>normalizedPath<span class="token punctuation">,</span> pathToRegexpOptions<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">components</span><span class="token operator">:</span> route<span class="token punctuation">.</span>components <span class="token operator">||</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token operator">:</span> route<span class="token punctuation">.</span>component <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">alias</span><span class="token operator">:</span> route<span class="token punctuation">.</span>alias
      <span class="token operator">?</span> <span class="token keyword">typeof</span> route<span class="token punctuation">.</span>alias <span class="token operator">===</span> <span class="token string">'string'</span>
        <span class="token operator">?</span> <span class="token punctuation">[</span>route<span class="token punctuation">.</span>alias<span class="token punctuation">]</span>
        <span class="token operator">:</span> route<span class="token punctuation">.</span>alias
      <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">instances</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">enteredCbs</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    name<span class="token punctuation">,</span>
    <span class="token literal-property property">beforeEnter</span><span class="token operator">:</span> route<span class="token punctuation">.</span>beforeEnter<span class="token punctuation">,</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  我们正常定义路由的组件时会配置<code>component</code>属性，而极少配置<code>components</code>，这时<code>record</code>内部就会把我们配置<code>component</code>再包裹一层对象，通过<code>default</code>属性去访问。这其实也是为了标准化<code>component</code>，具体为什么会这样设计可以看看官网命名视图。<br>
  再来看<code>flatMapComponents</code>方法，因为一个路由可能对应多个组件，所以就要获取到所有组件的守卫，说到这里忘了说明守卫的种类了。<code>Vue</code>中把守卫分成三种，全局守卫、路由独享守卫、组件内守卫。我们这里分析的<code>beforeRouteLeave</code>则属于组件内守卫。所以它是要去组件中获取的，最后把所有组件守卫通过<code>flatten</code>扁平化到一个数组中。<br>
  在<code>fn</code>中我们还有一个获取<code>guard</code>的逻辑没有分析。也就是<code>extractGuard</code> 逻辑</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">extractGuard</span> <span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">def</span><span class="token operator">:</span> Object <span class="token operator">|</span> Function<span class="token punctuation">,</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> string</span>
<span class="token punctuation">)</span><span class="token operator">:</span> NavigationGuard <span class="token operator">|</span> Array<span class="token operator">&lt;</span>NavigationGuard<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> def <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// extend now so that global mixins are applied.</span>
    def <span class="token operator">=</span> _Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>def<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> def<span class="token punctuation">.</span>options<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这里如果<code>def</code>是一<code>Object</code>那就通过<code>_Vue.extend</code>扩展为构造器。然后从它<code>options</code>上去取相应的路由守卫钩子函数。<br>
  所以到这里就比较明朗了<code>extractLeaveGuards</code>方法最后就是获取所以失活组件的<code>beforeRouteLeave</code>钩子函数组成的数组然后经过反转得到的。那么为什么最后要进行反转呢？因为我们<code>Vue</code>创建过程都是先父后子，卸载过程都是先子后父。我们<code>records</code>数组都是先父后子添加的，所以失活钩子要进行反转。最后这个数组通过<code>concat</code>连接到<code>queue</code>中。<br>
  接下来就是我们解析流程第三步：调用<code>beforeEach</code> 守卫，这个实现非常简单，就是把<code>this.router.beforeHooks</code>直接放到<code>queue</code>中。<code>beforeHooks</code>被初始化为一个空数组，它会在<code>router.beforeEach</code>方法中使用</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token function">beforeEach</span> <span class="token punctuation">(</span>fn<span class="token operator">:</span> Function<span class="token punctuation">)</span><span class="token operator">:</span> Function <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">registerHook</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beforeHooks<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  这里调用<code>registerHook</code>注册<code>hook</code>时会传入，<code>fn</code>是用户定义的全局前置守卫函数，使用如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>然后我们来看<code>registerHook</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">registerHook</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">list</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">fn</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span><span class="token operator">:</span> Function <span class="token punctuation">{</span>
  list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  其实就是把用户定义的<code>fn</code> push到<code>this.beforeHooks</code>中，然后还会返回一个删除该守卫的函数，如果调用它就会删除守卫。<br>
  接下来就是第四个流程：在重用的组件里调用<code>beforeRouteUpdate</code> 守卫。也就是调用<code>extractUpdateHooks(updated)</code>方法。<code>updated</code>就是重用组件的<code>record</code>集合。下面我们来看这个方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">extractUpdateHooks</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">updated</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>RouteRecord<span class="token operator">&gt;</span></span><span class="token punctuation">)</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token operator">?</span>Function<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">extractGuards</span><span class="token punctuation">(</span>updated<span class="token punctuation">,</span> <span class="token string">'beforeRouteUpdate'</span><span class="token punctuation">,</span> bindGuard<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  同样的方法去找组件<code>beforeRouteUpdate</code>钩子，然后这里就没有去反转了。<br>
  接下来就是第五个流程：在路由配置里调用 <code>beforeEnter</code>守卫。这个是路由独享钩子，然后是从<code>activated</code>中遍历去取<code>beforeEnter</code>钩子函数然后放到<code>queue</code>中。</p> <div class="language-js extra-class"><pre class="language-js"><code>activated<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">m</span> <span class="token operator">=&gt;</span> m<span class="token punctuation">.</span>beforeEnter<span class="token punctuation">)</span>
</code></pre></div><p>  接下来就是第六个流程：解析异步路由组件。解析异步组件是要解析<code>activated</code>中激活的组件，这个方法比较复杂，在<code>resolve-components.js</code>中</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">resolveAsyncComponents</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">matched</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>RouteRecord<span class="token operator">&gt;</span></span><span class="token punctuation">)</span><span class="token operator">:</span> Function <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> hasAsync <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">let</span> error <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token function">flatMapComponents</span><span class="token punctuation">(</span>matched<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">def<span class="token punctuation">,</span> _<span class="token punctuation">,</span> match<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// if it's a function and doesn't have cid attached,</span>
      <span class="token comment">// assume it's an async component resolve function.</span>
      <span class="token comment">// we are not using Vue's default async resolving mechanism because</span>
      <span class="token comment">// we want to halt the navigation until the incoming component has been</span>
      <span class="token comment">// resolved.</span>
      <span class="token comment">// 如果它是一个函数，并且没有附加cid，那么假设它是一种异步组件解析函数。我们没有使用</span>
      <span class="token comment">// Vue的默认异步解析机制，因为我们希望在解析传入组件之前停止导航。</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> def <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> def<span class="token punctuation">.</span>cid <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        hasAsync <span class="token operator">=</span> <span class="token boolean">true</span>
        pending<span class="token operator">++</span>
        <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token function">once</span><span class="token punctuation">(</span><span class="token parameter">resolvedDef</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isESModule</span><span class="token punctuation">(</span>resolvedDef<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            resolvedDef <span class="token operator">=</span> resolvedDef<span class="token punctuation">.</span>default
          <span class="token punctuation">}</span>
          <span class="token comment">// save resolved on async factory in case it's used elsewhere</span>
          def<span class="token punctuation">.</span>resolved <span class="token operator">=</span> <span class="token keyword">typeof</span> resolvedDef <span class="token operator">===</span> <span class="token string">'function'</span>
            <span class="token operator">?</span> resolvedDef
            <span class="token operator">:</span> _Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>resolvedDef<span class="token punctuation">)</span>
          match<span class="token punctuation">.</span>components<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> resolvedDef
          pending<span class="token operator">--</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">const</span> reject <span class="token operator">=</span> <span class="token function">once</span><span class="token punctuation">(</span><span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> msg <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Failed to resolve async component </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>reason<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
          process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            error <span class="token operator">=</span> <span class="token function">isError</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
              <span class="token operator">?</span> reason
              <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
            <span class="token function">next</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">let</span> res
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          res <span class="token operator">=</span> <span class="token function">def</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// new syntax in Vue 2.3</span>
            <span class="token keyword">const</span> comp <span class="token operator">=</span> res<span class="token punctuation">.</span>component
            <span class="token keyword">if</span> <span class="token punctuation">(</span>comp <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> comp<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              comp<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasAsync<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  可以看到这个返回也是返回一个类似于我们导航守卫的函数，首先定义了三个变量，然后就是执行<code>flatMapComponents</code>方法，但是这里的传入的<code>fn</code>函数变了，之前我们<code>fn</code>定义一大堆其实逻辑很简单就是把组件内守卫通过<code>bind</code>方法永久绑定<code>this</code>为组件实例后返回新的守卫函数。但是这里就复杂的多了，因为这里不确定用户定义的是同步还是异步。<br>
  所以接下来就是对异步组件的判断，如果<code>def</code>是一个函数并且d<code>ef.cid</code>不存在就认为它是一个异步组件，<code>def</code>就是用户配置的<code>component</code>，当然也可能是<code>components</code>，<code>def</code>是<code>default</code>的缩写，我们可能直接写一个引入的组件对象，也可能写一个函数并返回<code>import()</code>，如下例所示</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">component</span><span class="token operator">:</span> Home<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/a'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'../views/Home.vue'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p>  如果是写的第二种形式的路由的话就把<code>hasAsync</code>标识置为<code>true</code>，然后<code>pending++</code>。然后定义<code>resolve</code>为<code>once</code>函数返回结果。其实看到<code>once</code>我们已经知道它是做什么的，肯定是为了保证函数只执行一次，所以它接收的参数肯定是一个函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">once</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> called <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span>
    called <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这里使用<code>apply</code>主要是为了便于处理参数没有改变<code>this</code>指向的意思。接下来定义<code>resolve</code>函数，然后又定义了<code>reject</code>函数。接下来调用<code>def</code>函数，<code>def</code>最后会返回一个<code>promise</code>对象保存在<code>res</code>中。<br>
  再往下<code>res</code>存在并<code>res.then</code>是函数的话调用<code>res.then()</code>，如果<code>res.then</code>不存在那就是<code>vue2.3</code>之后才有的一种新语法，这里就不说了，没有见过这种情况。<br>
  执行<code>res.then()</code>时也就是执行<code>resolve</code>方法了，<code>resolve</code>方法首先判断<code>resolveDef</code>是不是一个<code>esmodule</code>，判断方法如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> hasSymbol <span class="token operator">=</span>
  <span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span>
  <span class="token keyword">typeof</span> Symbol<span class="token punctuation">.</span>toStringTag <span class="token operator">===</span> <span class="token string">'symbol'</span>

<span class="token keyword">function</span> <span class="token function">isESModule</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">.</span>__esModule <span class="token operator">||</span> <span class="token punctuation">(</span>hasSymbol <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toStringTag<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'Module'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  经过<code>import()</code>处理后组件会包含<code>__esModule</code>等属性，这个东西其实我们在分析异步组件时候已经见过了。其实这部分逻辑基本和异步组件实现是类似的，这里是在router中自定义了异步组件的实现，为什么重写一遍注释其实已经解释的很清楚了。<code>resloveDef</code>的<code>default</code>就是解析到的组件内容
</p><div class="center"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAS4AAABlCAMAAADEdv5qAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAGbUExURfz8/P///+fn5/j4+OLi4vX19d7e3vLy8tnZ2fDw8NfX1+7u7tbW1u3t7ezs7MjIySAhJKmqq/b29m9vcVBRUzs8P9vb3NXV1YiJir6/v2FhZHx8fpSVlrW1ttzc3czMzuXl5cHBw09QUsrN0bm6vcCBu7Jmrfr2+ogSgNGkzvbs9aJFm+LE4P319dtaWuqdnfvr6+J3d/HAwJaYnMvMzrCytF9jaIeKjuvr7JYvj+zZ62ltcc3O0O7u742Qk2hscdzd3oSHi3t+gnJ1ep6hpPb298gAAPbW1thKStQ3N+WFhc8fH6eprP7+/pGUl/X19sLExu+1tebm6JGTl/bt9d9pafTOzt/f4YeKjTw9QLl0tFFSVCEiJfz6/NGjzsePw/r0+e7c7Lhxs+PI4vTo88CCvI+P08rK6s2aydWs0urW6dmz1hoaplpav+7u+Hd3ypqa2Nzc8UREtuDC3t272q2t34ODz/f3/O/f7vHi7+vX6fn0+WlpxcyayPTLy9Q2Nu2qquXL4/nh4eeRkfTp8/Xp9Pni4nF1eQAAAAi2+9MAAACJdFJOU/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8A0YG4uAAAAAlwSFlzAAAOxAAADsQBlSsOGwAADTVJREFUeF7tnO9r20gax28O8ibzYm2OgE67SPQHwqLEP2IsKIUE5BBCAiIs+IWVF5ZitFXjXfW6uDUHu25juMu/fd9nZmRLtuO1em1JGn0J8ow01o+vPs8jaazJ31iprcVZaVcBGby0q4CMkq4iKukqpN3SriIyS7uKaFMwmpUq059yVYPMPUOVqpWKroqPSpvoMisav+yvtYuxfxxlFjwabaLrWNeed3WD6ZWKhju0fqWyZzzfM7hONb2LFsYeZsnGj0Ob6Kp2tZ+e64amw5YqO9KILgKsC7tYV2/CQZNVs/h999p0Zaxq1afGpdF/DpY0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"></div><p></p> <p>  然后把它直接赋值给<code>resolveDef</code>，然后通过<code>Vue.extend</code>把它变成一个构造器保存在<code>def.resolved</code>，这样就能在其它地方使用了。再往下把<code>match.components[key]</code>设置为<code>resolveDef</code>，也就是到这里异步组件加载完成了，异步获取到组件对象就肯定要赋值给<code>components.default</code>了，当然还可能有其他自定义的视图命名。然后执行<code>pending--</code>，所以<code>pending</code>表示正在解析的异步组件数，当组件解析完成后调用<code>next</code>进行下一步。<code>resolveAsyncComponents</code>返回的是单函数而不是数组，所以<code>next()</code>执行就可以直接进行到下一步了。但是又有点不对劲，明明我们传入<code>activated</code>数组去解析，结果只返回了一个函数，别忘了<code>flatMapComponents</code>就有遍历的功能，这就保证我们每个组件都能解析到了。<br>
  那<code>next</code>怎么保证所有组件都解析完成呢？那就要归功于异步了，解析时遍历都是同步的过程，也就是说<code>pending++</code>是同步执行的，而<code>resolve</code>是异步执行的，也就是说<code>pending--</code>都是异步的，所以<code>next</code>调用必然能保证所有组件解析完毕。<br>
  最后<code>flatMapComponents</code>都执行完发现没有异步组件的话也就是<code>hasAsync为false</code>，就直接调用<code>next()</code>。<br>
  可以看到<code>next</code>设计是非常巧妙的，每次调用它就说明这个程序执行完了，可以进行下一个程序了，如果我们定义守卫最后没有执行<code>next()</code>，程序就会卡在这里不会继续往下执行了，如果没有<code>next</code>，我们就很难处理异步组件了，所以<code>next</code>设计是很有必要的。那为什么又要暴露给用户使用，让用户每次都必须麻烦的去手动调用<code>next</code>呢？这是为了给用户更多的选择空间，可以方便用户做一些重定向操作。<br>
  到这里我们<code>queue</code>数组内容就分析完毕了。解析完异步组件后执行<code>next()</code>又进行下一步时<code>index</code>已经超过<code>queue</code>的最大索引。所以就要执行<code>runQueue</code>函数的回调函数逻辑了，那么下个小节我们就来分析回调函数逻辑。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./main/chapter8/8-5.html" class="prev">
        8.5 导航守卫（上）
      </a></span> <span class="next"><a href="/./main/chapter8/8-7.html">
        8.7 导航守卫（下）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.20317d9d.js" defer></script><script src="./assets/js/2.8a65079d.js" defer></script><script src="./assets/js/14.96a92186.js" defer></script>
  </body>
</html>
