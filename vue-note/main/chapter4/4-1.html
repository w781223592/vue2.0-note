<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>卷心菜笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./logo.jpg">
    <meta name="description" content="基于vue@2.6.14的学习笔记">
    
    <link rel="preload" href="./assets/css/0.styles.34509ede.css" as="style"><link rel="preload" href="./assets/js/app.cb86b5c8.js" as="script"><link rel="preload" href="./assets/js/2.8a65079d.js" as="script"><link rel="preload" href="./assets/js/37.57e976da.js" as="script"><link rel="prefetch" href="./assets/js/10.35fa5c54.js"><link rel="prefetch" href="./assets/js/11.a8d301ee.js"><link rel="prefetch" href="./assets/js/12.28dadb6d.js"><link rel="prefetch" href="./assets/js/13.959f52a9.js"><link rel="prefetch" href="./assets/js/14.9e967e5c.js"><link rel="prefetch" href="./assets/js/15.89c1bf18.js"><link rel="prefetch" href="./assets/js/16.78f7cadf.js"><link rel="prefetch" href="./assets/js/17.eee5b860.js"><link rel="prefetch" href="./assets/js/18.e94d03e8.js"><link rel="prefetch" href="./assets/js/19.c9b980d9.js"><link rel="prefetch" href="./assets/js/20.82c7f25f.js"><link rel="prefetch" href="./assets/js/21.5878b705.js"><link rel="prefetch" href="./assets/js/22.e7794d4a.js"><link rel="prefetch" href="./assets/js/23.b1e09bbf.js"><link rel="prefetch" href="./assets/js/24.e1df98bf.js"><link rel="prefetch" href="./assets/js/25.1c2fb721.js"><link rel="prefetch" href="./assets/js/26.36c3f7e0.js"><link rel="prefetch" href="./assets/js/27.a3f09949.js"><link rel="prefetch" href="./assets/js/28.123d6383.js"><link rel="prefetch" href="./assets/js/29.04a6e255.js"><link rel="prefetch" href="./assets/js/3.3554c1dd.js"><link rel="prefetch" href="./assets/js/30.f5e711c8.js"><link rel="prefetch" href="./assets/js/31.7ddb232a.js"><link rel="prefetch" href="./assets/js/32.3710a144.js"><link rel="prefetch" href="./assets/js/33.836eb573.js"><link rel="prefetch" href="./assets/js/34.c3f3eb0f.js"><link rel="prefetch" href="./assets/js/35.3e97ba3f.js"><link rel="prefetch" href="./assets/js/36.0ff1be33.js"><link rel="prefetch" href="./assets/js/38.778b591d.js"><link rel="prefetch" href="./assets/js/39.f89500e6.js"><link rel="prefetch" href="./assets/js/4.414ef3ae.js"><link rel="prefetch" href="./assets/js/40.0bb1a72b.js"><link rel="prefetch" href="./assets/js/41.1b14daa9.js"><link rel="prefetch" href="./assets/js/42.da61de9e.js"><link rel="prefetch" href="./assets/js/43.afa151ce.js"><link rel="prefetch" href="./assets/js/44.beed5647.js"><link rel="prefetch" href="./assets/js/45.15cb664e.js"><link rel="prefetch" href="./assets/js/46.19b76064.js"><link rel="prefetch" href="./assets/js/47.81dd06b3.js"><link rel="prefetch" href="./assets/js/48.da28ae74.js"><link rel="prefetch" href="./assets/js/49.6ec02c7d.js"><link rel="prefetch" href="./assets/js/5.7771716e.js"><link rel="prefetch" href="./assets/js/50.33adc7e6.js"><link rel="prefetch" href="./assets/js/51.ad4dcf8f.js"><link rel="prefetch" href="./assets/js/52.1f63a577.js"><link rel="prefetch" href="./assets/js/53.f08905cc.js"><link rel="prefetch" href="./assets/js/54.95edb54c.js"><link rel="prefetch" href="./assets/js/55.4ad5a772.js"><link rel="prefetch" href="./assets/js/56.d55c7dcb.js"><link rel="prefetch" href="./assets/js/57.2bdbd5d4.js"><link rel="prefetch" href="./assets/js/58.6996ec46.js"><link rel="prefetch" href="./assets/js/59.42c770e8.js"><link rel="prefetch" href="./assets/js/6.f0272f8f.js"><link rel="prefetch" href="./assets/js/60.9a43de0b.js"><link rel="prefetch" href="./assets/js/61.9fda2ee3.js"><link rel="prefetch" href="./assets/js/62.40ba97a6.js"><link rel="prefetch" href="./assets/js/63.a8ceda24.js"><link rel="prefetch" href="./assets/js/64.063b5356.js"><link rel="prefetch" href="./assets/js/65.609bfe39.js"><link rel="prefetch" href="./assets/js/66.10bbf1b3.js"><link rel="prefetch" href="./assets/js/67.ed6fbab5.js"><link rel="prefetch" href="./assets/js/68.edf47e53.js"><link rel="prefetch" href="./assets/js/69.58c89969.js"><link rel="prefetch" href="./assets/js/7.44545bae.js"><link rel="prefetch" href="./assets/js/70.44d1903b.js"><link rel="prefetch" href="./assets/js/71.f54eb805.js"><link rel="prefetch" href="./assets/js/72.e0f8bc14.js"><link rel="prefetch" href="./assets/js/73.2292a46a.js"><link rel="prefetch" href="./assets/js/74.259c6d32.js"><link rel="prefetch" href="./assets/js/75.a5535961.js"><link rel="prefetch" href="./assets/js/76.2e270b76.js"><link rel="prefetch" href="./assets/js/77.a4bffe25.js"><link rel="prefetch" href="./assets/js/78.e00f48eb.js"><link rel="prefetch" href="./assets/js/79.dd1ef766.js"><link rel="prefetch" href="./assets/js/8.54165142.js"><link rel="prefetch" href="./assets/js/80.6d018d78.js"><link rel="prefetch" href="./assets/js/81.8647d108.js"><link rel="prefetch" href="./assets/js/82.9c326a94.js"><link rel="prefetch" href="./assets/js/83.0a8e8403.js"><link rel="prefetch" href="./assets/js/84.e1f731e8.js"><link rel="prefetch" href="./assets/js/85.446cc3ec.js"><link rel="prefetch" href="./assets/js/86.7800fc8e.js"><link rel="prefetch" href="./assets/js/87.51a4cddc.js"><link rel="prefetch" href="./assets/js/88.5cb86311.js"><link rel="prefetch" href="./assets/js/89.11fe5589.js"><link rel="prefetch" href="./assets/js/9.2a932dde.js"><link rel="prefetch" href="./assets/js/90.b3555572.js">
    <link rel="stylesheet" href="./assets/css/0.styles.34509ede.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">卷心菜笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/./main/" aria-current="page" class="sidebar-link">前言</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 初识Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter1/1-1.html" class="sidebar-link">1.1 Vue目录设计</a></li><li><a href="/./main/chapter1/1-2.html" class="sidebar-link">1.2 Vue入口文件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 Vue初始化和挂载</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter2/2-1.html" class="sidebar-link">2.1 new Vue()时做了什么</a></li><li><a href="/./main/chapter2/2-2.html" class="sidebar-link">2.2 Vue实例挂载的实现</a></li><li><a href="/./main/chapter2/2-3.html" class="sidebar-link">2.3 Vue挂载时的mountComponent</a></li><li><a href="/./main/chapter2/2-4.html" class="sidebar-link">2.4 Virtual DOM</a></li><li><a href="/./main/chapter2/2-5.html" class="sidebar-link">2.5 最终的挂载方法_update</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第三章 组件化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter3/3-1.html" class="sidebar-link">3.1 创建组件vnode</a></li><li><a href="/./main/chapter3/3-2.html" class="sidebar-link">3.2组件的patch过程</a></li><li><a href="/./main/chapter3/3-3.html" class="sidebar-link">3.3合并配置</a></li><li><a href="/./main/chapter3/3-4.html" class="sidebar-link">3.4生命周期（上）</a></li><li><a href="/./main/chapter3/3-5.html" class="sidebar-link">3.5生命周期（下）</a></li><li><a href="/./main/chapter3/3-6.html" class="sidebar-link">3.6组件的注册</a></li><li><a href="/./main/chapter3/3-7.html" class="sidebar-link">3.7 异步组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第四章 响应式原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter4/4-1.html" aria-current="page" class="active sidebar-link">4.1 响应式对象</a></li><li><a href="/./main/chapter4/4-2.html" class="sidebar-link">4.2 依赖收集（上）</a></li><li><a href="/./main/chapter4/4-3.html" class="sidebar-link">4.3 依赖收集（下）</a></li><li><a href="/./main/chapter4/4-4.html" class="sidebar-link">4.4 派发更新</a></li><li><a href="/./main/chapter4/4-5.html" class="sidebar-link">4.5 nextTick</a></li><li><a href="/./main/chapter4/4-6.html" class="sidebar-link">4.6 检测变化的坑</a></li><li><a href="/./main/chapter4/4-7.html" class="sidebar-link">4.7 计算属性</a></li><li><a href="/./main/chapter4/4-8.html" class="sidebar-link">4.8 侦听器</a></li><li><a href="/./main/chapter4/4-9.html" class="sidebar-link">4.9 组件更新</a></li><li><a href="/./main/chapter4/4-10.html" class="sidebar-link">4.10 diff算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter5/5-1.html" class="sidebar-link">5.1 初探编译器</a></li><li><a href="/./main/chapter5/5-2.html" class="sidebar-link">5.2 从入口开始</a></li><li><a href="/./main/chapter5/5-3.html" class="sidebar-link">5.3 parse之解析模板（上）</a></li><li><a href="/./main/chapter5/5-4.html" class="sidebar-link">5.4 parse之解析模板（下）</a></li><li><a href="/./main/chapter5/5-5.html" class="sidebar-link">5.5 parse之生成AST（1）</a></li><li><a href="/./main/chapter5/5-6.html" class="sidebar-link">5.6 parse之生成AST（2）</a></li><li><a href="/./main/chapter5/5-7.html" class="sidebar-link">5.7 parse之生成AST（3）</a></li><li><a href="/./main/chapter5/5-8.html" class="sidebar-link">5.8 parse之生成AST（4）</a></li><li><a href="/./main/chapter5/5-9.html" class="sidebar-link">5.9 parse之生成AST（5）</a></li><li><a href="/./main/chapter5/5-10.html" class="sidebar-link">5.10 optimize优化</a></li><li><a href="/./main/chapter5/5-11.html" class="sidebar-link">5.11 generate代码生成（1）</a></li><li><a href="/./main/chapter5/5-12.html" class="sidebar-link">5.12 generate代码生成（2）</a></li><li><a href="/./main/chapter5/5-13.html" class="sidebar-link">5.13 generate代码生成（3）</a></li><li><a href="/./main/chapter5/5-14.html" class="sidebar-link">5.14 generate代码生成（4）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter6/6-1.html" class="sidebar-link">6.1 events（1）</a></li><li><a href="/./main/chapter6/6-2.html" class="sidebar-link">6.2 events（2）</a></li><li><a href="/./main/chapter6/6-3.html" class="sidebar-link">6.3 events（3）</a></li><li><a href="/./main/chapter6/6-4.html" class="sidebar-link">6.4 events（4）</a></li><li><a href="/./main/chapter6/6-5.html" class="sidebar-link">6.5 v-model（1）</a></li><li><a href="/./main/chapter6/6-6.html" class="sidebar-link">6.6 v-model（2）</a></li><li><a href="/./main/chapter6/6-7.html" class="sidebar-link">6.7v-model（3）</a></li><li><a href="/./main/chapter6/6-8.html" class="sidebar-link">6.8v-model（4）</a></li><li><a href="/./main/chapter6/6-9.html" class="sidebar-link">6.9 slot（上）</a></li><li><a href="/./main/chapter6/6-10.html" class="sidebar-link">6.10 slot（中）</a></li><li><a href="/./main/chapter6/6-11.html" class="sidebar-link">6.11 slot（下）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 内置组件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter7/7-1.html" class="sidebar-link">7.1 keep-alive（上）</a></li><li><a href="/./main/chapter7/7-2.html" class="sidebar-link">7.2 keep-alive（下）</a></li><li><a href="/./main/chapter7/7-3.html" class="sidebar-link">7.3 transition（上）</a></li><li><a href="/./main/chapter7/7-4.html" class="sidebar-link">7.4 transition（中）</a></li><li><a href="/./main/chapter7/7-5.html" class="sidebar-link">7.5 transition（下）</a></li><li><a href="/./main/chapter7/7-6.html" class="sidebar-link">7.6 transition-group</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第八章 Vue-router</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter8/8-1.html" class="sidebar-link">8.1 vue-router的注册</a></li><li><a href="/./main/chapter8/8-2.html" class="sidebar-link">8.2 VueRouter实例化</a></li><li><a href="/./main/chapter8/8-3.html" class="sidebar-link">8.3 动态路由</a></li><li><a href="/./main/chapter8/8-4.html" class="sidebar-link">8.4 match</a></li><li><a href="/./main/chapter8/8-5.html" class="sidebar-link">8.5 导航守卫（上）</a></li><li><a href="/./main/chapter8/8-6.html" class="sidebar-link">8.6 导航守卫（中）</a></li><li><a href="/./main/chapter8/8-7.html" class="sidebar-link">8.7 导航守卫（下）</a></li><li><a href="/./main/chapter8/8-8.html" class="sidebar-link">8.8 路径切换</a></li><li><a href="/./main/chapter8/8-9.html" class="sidebar-link">8.9 router-view组件</a></li><li><a href="/./main/chapter8/8-10.html" class="sidebar-link">8.10 router-link组件</a></li><li><a href="/./main/chapter8/8-11.html" class="sidebar-link">8.11 history模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>  我们前面章节主要讲解<code>Vue</code>初始化渲染的过程，我们都知道<code>Vue</code>的核心思想是数据驱动，也就是数据的改变会导致视图的变化，我们之前讲解并没有涉及这一过程，我们之前讲解的过程更像一个静态页面的加载过程，尽管<code>Vue</code>在此过程中做了很多事，但这些事更像是拐弯抹角的去操作dom，如果我们直接用html去写页面，它省去了<code>Vue</code>的很多判断，会更快的在页面上展示出内容。所以<code>Vue</code>的核心优势到底在哪呢？<br>
  我们都知道<code>Vue</code>的数据是响应式的，数据的改变会导致视图的变化，这其实就是我们问题的答案，这就是<code>Vue</code>的核心优势。这个答案是否是很简单呢？其实它一点都不简单，首先我们要清楚一点，使用原生js一定是最快的，但是这是理论上的最快。如果对比首次加载，我们使用原生js、html肯定是比<code>Vue</code>要快的，因为<code>Vue</code>做了太多的前期工作，相比于html直接渲染标签要慢多了，但是浏览器dom对象十分庞大，它的渲染要花大量时间，这个时间是要比js运行大的多，所以我们要尽可能少的操作dom。少的操作dom说起来容易，但是想要做到会给程序员带来极大的心智负担，假如想要改页面上的一块内容，我们自己来写会怎么做呢？先找到要修改的内容，也就是要去获取dom，然后需要考虑怎么改是最优的，如果需要修改地方很多，你需要做的工作是不可想象的，因为你想做的性能最优你就要做出更多的工作，假如一个1000项的长列表更新了其中十项内容，那你就得做十次相同工作，或者说写个方法找出这10个改变的地方，那如果说你直接重新替换这1000项，那么你就轻松多了，但你这时效率就不是最高的了。所以这个时候你就会有选择了，到底是为了效率去耗费更多心智负担，还是为了轻松一些牺牲一些效率。<code>Vue</code>在这里就体现了一个权衡的艺术，它降低的开发者的心智负担而尽可能的使效率接近原生js，尽管原生js的效率可能仅存在于理论中。<br>
  那<code>Vue</code>在这过程中做了什么事呢？它会自动帮我们找到想要修改的dom，然后去做最优的修改方案。开发者只需要关注数据改变就可以，而不需要去使用dom，这就使开发变的简单的多。接下来我们就去看看<code>Vue</code>是怎么实现这一神奇的功能的吧。</p> <h1 id="_4-1-响应式对象"><a href="#_4-1-响应式对象" class="header-anchor">#</a> 4.1 响应式对象</h1> <p>  我们在<code>Vue</code>初始化执行<code>_init</code>方法时执行了很多初始化方法，我们之前很多只是做了很简单介绍或者就直接跳过了，现在我们就来看其中的<code>initState</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  先在<code>vm</code>上创建了一个空的集合<code>_watchers</code>，之后获取<code>$options</code>，然后分别对<code>props、methods、data</code>进行初始化，如果<code>data</code>存在就执行<code>initData</code>，否则执行<code>observe</code>方法。我们先继续往下看，之后又进行<code>computed</code>的初始化，最后是对<code>watch</code>的初始化，这里是做了个特殊判断就是<code>opts.watch</code>不等于<code>nativeWatch</code>才执行，这是怎么一回事呢？其实这跟上面没什么区别就是判断我们定义了<code>watch</code>，但是由于浏览器兼容性问题所以需要特别处理一下。<br>
  我们去<code>util/env.js</code>下找一下<code>nativeWatch</code>的定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Firefox has a &quot;watch&quot; function on Object.prototype...</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> nativeWatch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>watch
</code></pre></div><p>  定义个空对象并取它的<code>watch</code>方法，为什么弄个这东西出来呢，看上面这段注释，就是说火狐浏览器的<code>Object</code>的原型上已经有<code>watch</code>方法了，所以我们<code>opts.watch</code>可能取到的不是我们定义的<code>watch</code>方法，为了排除这种情况所以做了这层判断。<br>
  在处理<code>data</code>过程中有个重要方法，就是我们<code>observe</code>方法，下面我们来看一下<code>observe</code>方法做了什么事，它定义在<code>observer/index.js</code>下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */</span>
<span class="token comment">// 尝试为值创建观察者实例，如果观察成功，则返回新的观察者；如果值已经有一个观察者，则返回现有的观察者  </span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">observe</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token literal-property property">asRootData</span><span class="token operator">:</span> <span class="token operator">?</span>boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> Observer <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> value <span class="token keyword">instanceof</span> <span class="token class-name">VNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> <span class="token literal-property property">ob</span><span class="token operator">:</span> Observer <span class="token operator">|</span> <span class="token keyword">void</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span>__ob__ <span class="token keyword">instanceof</span> <span class="token class-name">Observer</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> value<span class="token punctuation">.</span>__ob__
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
    shouldObserve <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>value<span class="token punctuation">.</span>_isVue
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>asRootData <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ob<span class="token punctuation">.</span>vmCount<span class="token operator">++</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ob
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法接收了两个参数，第一个是<code>value</code>，就是我们要监听的对象，第二个是<code>asRootData</code>，其实就是根对象，也就是我们的<code>data</code>对象，我们可以看到在<code>initState</code>中调用时传入的第一个参数，初始化<code>data</code>是有两个分支，<code>opts.data</code>存在时执行<code>initData</code>方法，<code>initData</code>最后其实也是执行了<code>observe</code>方法，这个我们在<code>initState文档</code>中已经提到过了，这里传入的第一个参数其实都是<code>data</code>，第二个参数都为<code>true</code>。<br>
  接下来我们分析<code>observe</code>执行逻辑，它首先判断<code>value</code>是不是对象，如果<code>value</code>不是对象或者它是<code>vnode</code>实例就什么事都不做直接return。否则的话执行后面逻辑，定义<code>ob</code>变量，如果<code>value</code>上有<code>'__ob__'</code>属性并且<code>value.__ob__</code>是<code>Observer</code>的实例，那就将ob赋值为<code>value.__ob__</code>；再如果</p> <div class="language-js extra-class"><pre class="language-js"><code>  shouldObserve <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span><span class="token function">isServerRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>value<span class="token punctuation">.</span>_isVue  
</code></pre></div><p>  这个判断条件有点长，它是五个条件，首先是<code>shouldObserve</code>为<code>true</code>，<code>shouldObserve</code>是当前文件下定义的全局变量</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token literal-property property">shouldObserve</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">true</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">toggleObserving</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  shouldObserve <span class="token operator">=</span> value
<span class="token punctuation">}</span>
</code></pre></div><p>  可以看到它初始值为<code>true</code>，下面它又定义了<code>toggleObserving</code>方法，通过这个方法可以改变<code>shouldObserve</code>，它其实是个控制是否监听的开关变量。<br>
  第二个条件是它不是在服务端渲染中，第三个条件是<code>value</code>是一个数组或者对象，第四个条件是<code>value</code>必须是可扩展对象，第五个条件是<code>value</code>没有<code>_isVu</code>e属性，就是防止我们去监听<code>Vue</code>的实例，满足这五个条件就去<code>new Observer</code>，<code>new</code>出来的对象赋值给<code>ob</code>，最后如果<code>asRootData</code>为<code>true</code>并且<code>ob</code>被赋值的话就使<code>ob.vmCount ++</code>，最后返回<code>ob</code>。<br>
  接下来我们看看<code>Observer</code>是做什么的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">value</span><span class="token operator">:</span> any<span class="token punctuation">;</span>
  <span class="token literal-property property">dep</span><span class="token operator">:</span> Dep<span class="token punctuation">;</span>
  <span class="token literal-property property">vmCount</span><span class="token operator">:</span> number<span class="token punctuation">;</span> <span class="token comment">// number of vms that have this object as root $data</span>

  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
    <span class="token keyword">this</span><span class="token punctuation">.</span>dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vmCount <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">'__ob__'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>hasProto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">protoAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">copyAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */</span>
  <span class="token function">walk</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">obj</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * Observe a list of Array items.
   */</span>
  <span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">items</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  可以看到<code>Observer</code>其实是个<code>class</code>类，先看它的构造器，接收一个参数<code>value</code>，先用<code>value</code>属性保存<code>value</code>值，然后创建<code>dep</code>属性为<code>new Dep()</code>，<code>Dep()</code>构造器我们之后再分析它，继续往下看创建<code>vmCount</code>属性并设初值为0。
  接下来又调用<code>def</code>方法，我们来看<code>def</code>方法做了什么事，<code>def</code>方法定义于<code>util/lang.js</code>中</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">def</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">obj</span><span class="token operator">:</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token literal-property property">val</span><span class="token operator">:</span> any<span class="token punctuation">,</span> enumerable<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> val<span class="token punctuation">,</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span>enumerable<span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这里<code>def</code>方法实际上是封装<code>Object.defineProperty</code>方法，这里劫持的对象是<code>value</code>，劫持的属性是<code>'__ob__'</code>，这里实际是新增了<code>__ob__</code>属性，属性值就是this，这里的this是new构造的对象，至于第四个参数是决定属性是否可枚举，这里是默认的<code>false</code>，也就是不可枚举，这里使用<code>def</code>方法实际上是将<code>__ob__</code>属性处理为一个不可枚举属性，防止之后在使用过程中遍历到它，假设一个<code>data</code>对象经过<code>def</code>处理后会得到下面这种形式。</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// __ob__ 是不可枚举的属性</span>
  <span class="token literal-property property">__ob__</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> data<span class="token punctuation">,</span> <span class="token comment">// value 属性指向 data 数据对象本身，这是一个循环引用</span>
    <span class="token literal-property property">dep</span><span class="token operator">:</span> dep实例对象<span class="token punctuation">,</span> <span class="token comment">// new Dep()</span>
    <span class="token literal-property property">vmCount</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  接下来判断如果<code>value</code>是一个数组的话执行if分支，如果<code>hasProto</code>为真则执行<code>protoAugment</code>，否则执行<code>copyAugment</code>方法。最后再执行<code>this.observeArray</code>方法，如果<code>value</code>不是数组则进入<code>else</code>分支执行<code>this.walk</code>方法。
<code>protoAugment</code>方法和<code>copyAugment</code>方法我们后面再来分析，<code>observeArray</code>方法比较简单，就是遍历<code>value</code>递归调用<code>observe</code>方法，<code>walk</code>方法也是非常简单，在<code>value</code>为对象时遍历并执行<code>defineReactive</code>方法，接下来我们就看看<code>defineReactive</code>方法做了什么事吧！</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">defineReactive</span> <span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">obj</span><span class="token operator">:</span> Object<span class="token punctuation">,</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> string<span class="token punctuation">,</span>
  <span class="token literal-property property">val</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  customSetter<span class="token operator">?</span><span class="token operator">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span>
  shallow<span class="token operator">?</span><span class="token operator">:</span> boolean</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">const</span> property <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>configurable <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// cater for pre-defined getter/setters</span>
  <span class="token keyword">const</span> getter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>get
  <span class="token keyword">const</span> setter <span class="token operator">=</span> property <span class="token operator">&amp;&amp;</span> property<span class="token punctuation">.</span>set
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>getter <span class="token operator">||</span> setter<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          childOb<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dependArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val
      <span class="token comment">/* eslint-disable no-self-compare */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">===</span> value <span class="token operator">||</span> <span class="token punctuation">(</span>newVal <span class="token operator">!==</span> newVal <span class="token operator">&amp;&amp;</span> value <span class="token operator">!==</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
      <span class="token comment">/* eslint-enable no-self-compare */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> customSetter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">customSetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// #7981: for accessor properties without setter</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>getter <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>setter<span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>setter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        val <span class="token operator">=</span> newVal
      <span class="token punctuation">}</span>
      childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这个方法参数是比较多的，第一个参数<code>obj</code>，第二个参数为<code>key</code>，第三个参数为<code>val</code>，第四个参数<code>customSetter</code>，第五个参数<code>shallow</code>，这是一个浅的响应式定义标识，如果我们传为<code>true</code>，它之后对数据做浅层响应式处理，而不会深度遍历。这里我们值传入了前两个参数。<br>
  我们来看函数逻辑，首先定<code>dep</code>引用<code>new Dep()</code>的实例化对象。这里我还是暂时不去分析<code>Dep</code>，接着往下获取<code>key</code>属性描述，然后判断改属性的描述如果是不能修改的，就直接<code>return</code>，因为后续我们就是想要修改它的属性描述。如果可以修改描述我们就进行后面操作，先获取它的<code>get</code>和<code>set</code>，因为我们定义数据时可能会给它定义<code>get</code>和<code>set</code>方法，这里也是通过闭包的技巧保存原有的<code>get</code>和<code>set</code>，之后重定义<code>Object.defineProperty</code>时候使用<code>get</code>和<code>set</code>以保证最后能返回正确的结果。接着如果<code>getter</code>不存在或者<code>setter</code>存在并且只传了两个参数时将<code>val</code>设置为<code>obj[key]</code>。
  接下来的一段逻辑是比较重要的，在重定义<code>Object.defineProperty</code>时，如同<code>get</code>和<code>set</code>一样<code>childOb</code>同样也是以闭包的形式在新的<code>get</code>中引用，所以我们这里要清楚的知道它是个什么东西。首先它其实是先判断<code>!shallow</code>，<code>shallow</code>意思是浅层的，相对的就是<code>deep</code>了，这里是判断非浅层的，那么要对它做深度响应式了，也就是递归调用<code>observe</code>了，这里不要忘了，我们一直是在分析<code>observe</code>函数的，这里多层函数以及<code>class</code>嵌套可能有一点绕，但是我们要清楚我们还没有跳出<code>observe</code>函数，而这里又一次调用<code>observe</code>，所以它是递归的，回到<code>observe</code>函数中第一句逻辑是判断传入的参数是不是对象，当然这里是广义上的对象，数组也包括在内。换句话说就是有对象嵌套的情况下<code>childOb</code>才会有值。所以我们不妨把<code>data</code>定义再稍微复杂一点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 属性 a 通过 setter/getter 通过闭包引用着 dep 和 childOb</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性 b 通过 setter/getter 通过闭包引用着 dep 和 childOb</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">1</span>
    <span class="token literal-property property">__ob__</span><span class="token operator">:</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> dep<span class="token punctuation">,</span> vmCount<span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token literal-property property">__ob__</span><span class="token operator">:</span> <span class="token punctuation">{</span>data<span class="token punctuation">,</span> dep<span class="token punctuation">,</span> vmCount<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  我们总结分析一下<code>observe</code>其实就是返回了<code>new Observer</code>实例化对象<code>ob</code>，不管它中间有多复杂的判断，最终结果是不会变的。而<code>new Observer</code>就是为对象添加了<code>__ob__</code>，然后再对对象的各个属性值为引用类型数据的属性递归<code>observe</code>，但是对于纯对象递归时绕了个弯，通过执行<code>defineReactive</code>方法再去执行<code>observe</code>，而执行<code>observe</code>其实就是定义<code>childOb</code>这一步，所以这里<code>data.a</code>的<code>childOb</code>实际上是对<code>data.a</code>对象<code>observe</code>执行结果，<code>observe</code>执行结果又是<code>new Observer</code>实例化的对象。所以<code>childOb</code>就是<code>Observer</code>类实例化对象，而实例化<code>Observer</code>过程中为原对象添加<code>__ob__</code>属性并且赋值为<code>this</code>，也就是<code>__ob__</code>属性就是实例化出的对象。换句话说<code>observe(data.a)</code>等于<code>data.a.__ob__</code>。<br>
  我们再回到<code>defineReactive</code>函数中，这时就比较清晰了，<code>observe(data)</code>时，会遍历<code>data</code>中的属性进行<code>Object.defineProperty</code>劫持，显然<code>defineReactive</code>就是做属性劫持的，然后<code>childOb</code>就是在<code>defineReactive</code>中创建的，劫持<code>a</code>的时候，<code>childOb就是data.a. __ob__</code>，劫持<code>c</code>的时候它是<code>undefined</code>，因为<code>c</code>不是个对象，不会再深度监听。这样就将<code>childOb</code>讲清楚了，这个在后面会有重要作用。<br>
  最后就是对对象<code>key</code>属性进行<code>Object.defineProperty</code>劫持，如果定义对象时已经配置过它的特性，这里可以看成是重写了它的特性，那么重写<code>Object.defineProperty</code>后会不会使得对象变得超出我们预期呢？换句话说就是重写后会不会与我们初始定义相悖呢？比如说我们为data添加如下劫持</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>  这里我给<code>data</code>定义了数据属性，没有定义<code>get</code>和<code>set</code>，而我们可以看到重定义后是有<code>get</code>和<code>set</code>的，那这是不是和我们预期结果不符了呢？表面上看它的属性描述确实是变化了，但是这并不会影响我们对它的其它操作。<br>
  首先来说<code>configurable</code> ，它如果为<code>false</code>的话在<code>defineReactive</code>中一开始就做了判断，所以它只能是<code>true</code>。<br> <code>enumerable</code>是否可枚举，仔细想一想<code>defineReactive</code>是不是遍历对象属性调用的呢？不可枚举属性不会触发<code>defineReactive</code>，所以它也是<code>true</code>。<br> <code>value</code>和<code>writable</code>属于数据属性的特性，而重写后我们增加了<code>get</code>和<code>set</code>，我们知道数据属性和访问器属性是可以相互转化的。我们增加了<code>get</code>和<code>set</code>后就会从数据属性转化为访问器属性，那么这两个属性就无效了。这两个属性是令人头疼的，因为它实在是没有什么用，没有人会期望在响应数据中设置<code>writable</code>为<code>false</code>，一个不期望修改的数据也是没什么必要定义在<code>data</code>中的，所以我们这里直接用<code>get</code>和<code>set</code>覆盖它们让它变成访问器属性。
<code>get</code>和<code>set</code>属于访问器属性，重写前实际上是先取到它的<code>get</code>和<code>set</code>分别保存在<code>getter</code>和<code>setter</code>，之后重写<code>get</code>和<code>set</code>时分别调用它们返回预期结果，重写的目的就是为了能在<code>get</code>和<code>set</code>中增加一些操作，比如下节我们要讲的依赖收集就是在<code>get</code>函数中进行的。<br>
  接着往下看<code>defineReactive</code>可以看到它有复杂的<code>get</code>和<code>set</code>定义，这里的一大串逻辑就是响应式数据的实现，其具体逻辑我们之后小节分析。<br>
  最后我们再次分析一下下面这段代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>getter <span class="token operator">||</span> setter<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  val <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这段代码产生是源于一个<code>issue</code>，就是让它在<code>getter</code>存在时不执行<code>val=obj[key]</code>，因为这个操作会触发<code>getter</code>拦截，因为不知道用户会在<code>getter</code>中做什么操作，所以为了防止这种意外产生，有<code>getter</code>时候不获取<code>val</code>，这样<code>val</code>值没有传入时为<code>undefined</code>，也就不会做深度响应式了。但是这样有一个问题，当它重定义<code>Object.defineProperty</code>增加<code>get</code>和<code>set</code>，当它被修改时候会触发<code>set</code>拦截，这里可以先剧透一下<code>set</code>方法中也是有<code>observe</code>的，如果我们给它定义了<code>setter</code>，它会取新的<code>val</code>值进行观察，这样从原来不是深度观察变为了深度观察，变的不统一了，为了解决这个问题演变为<code>!getter || setter</code>判断，这样在有<code>setter</code>时候即使<code>getter</code>存在也会取<code>val</code>值。这个仅作为了解即可。<br>
  这一小节我们讲解了如何定义一个响应式对象，就是通过<code>Object.defineProperty</code>对对象的访问和修改进行拦截。但是可能你还是不明白响应式数据的工作过程，因为我们还没有深入分析它的实现，可能聪明的你已经想我们在修改响应式数据时会执行<code>set</code>方法，通过<code>set</code>方法去更新视图，但是set又如何找到需要更新哪些地方呢？这就得益于我们get拦截中的依赖收集方法了，那么我们下一个小节就分析依赖收集过程。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./main/chapter3/3-7.html" class="prev">
        3.7 异步组件
      </a></span> <span class="next"><a href="/./main/chapter4/4-2.html">
        4.2 依赖收集（上）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.cb86b5c8.js" defer></script><script src="./assets/js/2.8a65079d.js" defer></script><script src="./assets/js/37.57e976da.js" defer></script>
  </body>
</html>
