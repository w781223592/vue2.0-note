<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>4.9 组件更新 | 卷心菜笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./logo.jpg">
    <meta name="description" content="基于vue@2.6.14的学习笔记">
    
    <link rel="preload" href="./assets/css/0.styles.88a4e9f5.css" as="style"><link rel="preload" href="./assets/js/app.d5acc79b.js" as="script"><link rel="preload" href="./assets/js/2.b590321b.js" as="script"><link rel="preload" href="./assets/js/41.aff618f5.js" as="script"><link rel="prefetch" href="./assets/js/10.28c22c34.js"><link rel="prefetch" href="./assets/js/11.b72984a2.js"><link rel="prefetch" href="./assets/js/12.7a356702.js"><link rel="prefetch" href="./assets/js/13.4d2ebb73.js"><link rel="prefetch" href="./assets/js/14.7e5c333b.js"><link rel="prefetch" href="./assets/js/15.33ab5b85.js"><link rel="prefetch" href="./assets/js/16.26bfda56.js"><link rel="prefetch" href="./assets/js/17.f8249aae.js"><link rel="prefetch" href="./assets/js/18.8b77e49e.js"><link rel="prefetch" href="./assets/js/19.4ea26ad8.js"><link rel="prefetch" href="./assets/js/20.5c1ea347.js"><link rel="prefetch" href="./assets/js/21.439ae5de.js"><link rel="prefetch" href="./assets/js/22.bc9ba01a.js"><link rel="prefetch" href="./assets/js/23.065a389a.js"><link rel="prefetch" href="./assets/js/24.f02ba9a4.js"><link rel="prefetch" href="./assets/js/25.dc260f1b.js"><link rel="prefetch" href="./assets/js/26.244eb099.js"><link rel="prefetch" href="./assets/js/27.e697ae03.js"><link rel="prefetch" href="./assets/js/28.a44f6cb5.js"><link rel="prefetch" href="./assets/js/29.a2c96871.js"><link rel="prefetch" href="./assets/js/3.609c0cd5.js"><link rel="prefetch" href="./assets/js/30.6bee233a.js"><link rel="prefetch" href="./assets/js/31.526a0347.js"><link rel="prefetch" href="./assets/js/32.ec625040.js"><link rel="prefetch" href="./assets/js/33.176d019f.js"><link rel="prefetch" href="./assets/js/34.f8e99996.js"><link rel="prefetch" href="./assets/js/35.99d9ab20.js"><link rel="prefetch" href="./assets/js/36.3ac859f6.js"><link rel="prefetch" href="./assets/js/37.56c9e9af.js"><link rel="prefetch" href="./assets/js/38.79ffb3a9.js"><link rel="prefetch" href="./assets/js/39.78873087.js"><link rel="prefetch" href="./assets/js/4.8492e10d.js"><link rel="prefetch" href="./assets/js/40.090b8936.js"><link rel="prefetch" href="./assets/js/42.b7419902.js"><link rel="prefetch" href="./assets/js/43.08762476.js"><link rel="prefetch" href="./assets/js/44.c271147a.js"><link rel="prefetch" href="./assets/js/45.e3aa209f.js"><link rel="prefetch" href="./assets/js/46.e9f719cf.js"><link rel="prefetch" href="./assets/js/47.9dbe7a9c.js"><link rel="prefetch" href="./assets/js/48.6d4f4e24.js"><link rel="prefetch" href="./assets/js/49.d8c44484.js"><link rel="prefetch" href="./assets/js/5.9754c995.js"><link rel="prefetch" href="./assets/js/50.06915873.js"><link rel="prefetch" href="./assets/js/51.95bc78ef.js"><link rel="prefetch" href="./assets/js/52.1bb1ed2a.js"><link rel="prefetch" href="./assets/js/53.85e86e9e.js"><link rel="prefetch" href="./assets/js/54.09fdaeea.js"><link rel="prefetch" href="./assets/js/55.d4016f45.js"><link rel="prefetch" href="./assets/js/56.dba7b1b2.js"><link rel="prefetch" href="./assets/js/57.9dde0f1c.js"><link rel="prefetch" href="./assets/js/58.72119fb4.js"><link rel="prefetch" href="./assets/js/59.487cd045.js"><link rel="prefetch" href="./assets/js/6.e61ed567.js"><link rel="prefetch" href="./assets/js/60.0d871d2d.js"><link rel="prefetch" href="./assets/js/61.533b4fa7.js"><link rel="prefetch" href="./assets/js/62.aaa2503f.js"><link rel="prefetch" href="./assets/js/63.7f5805e7.js"><link rel="prefetch" href="./assets/js/64.9db1f00f.js"><link rel="prefetch" href="./assets/js/65.d081a9d0.js"><link rel="prefetch" href="./assets/js/66.e26704f9.js"><link rel="prefetch" href="./assets/js/67.3a264983.js"><link rel="prefetch" href="./assets/js/68.285e16f9.js"><link rel="prefetch" href="./assets/js/69.6c656e15.js"><link rel="prefetch" href="./assets/js/7.2adcf0d8.js"><link rel="prefetch" href="./assets/js/70.8579a645.js"><link rel="prefetch" href="./assets/js/71.45029e1d.js"><link rel="prefetch" href="./assets/js/72.d94d691b.js"><link rel="prefetch" href="./assets/js/73.4b07003f.js"><link rel="prefetch" href="./assets/js/74.360630d3.js"><link rel="prefetch" href="./assets/js/75.fbb3c111.js"><link rel="prefetch" href="./assets/js/76.cc64c3e2.js"><link rel="prefetch" href="./assets/js/77.31e5cc90.js"><link rel="prefetch" href="./assets/js/78.acb73a36.js"><link rel="prefetch" href="./assets/js/79.232d6d8b.js"><link rel="prefetch" href="./assets/js/8.f23d7123.js"><link rel="prefetch" href="./assets/js/80.055408d9.js"><link rel="prefetch" href="./assets/js/81.955667b3.js"><link rel="prefetch" href="./assets/js/82.d60cdc5d.js"><link rel="prefetch" href="./assets/js/83.a5260291.js"><link rel="prefetch" href="./assets/js/84.790bfe99.js"><link rel="prefetch" href="./assets/js/85.8c50e659.js"><link rel="prefetch" href="./assets/js/86.4e4dd176.js"><link rel="prefetch" href="./assets/js/87.9c713ef2.js"><link rel="prefetch" href="./assets/js/88.1b1f4df4.js"><link rel="prefetch" href="./assets/js/89.c7c6f297.js"><link rel="prefetch" href="./assets/js/9.d5fa6ae7.js"><link rel="prefetch" href="./assets/js/90.5bfdf869.js">
    <link rel="stylesheet" href="./assets/css/0.styles.88a4e9f5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">卷心菜笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/./main/" aria-current="page" class="sidebar-link">前言</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 初识Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter1/1-1.html" class="sidebar-link">1.1 Vue目录设计</a></li><li><a href="/./main/chapter1/1-2.html" class="sidebar-link">1.2 Vue入口文件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 Vue初始化和挂载</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter2/2-1.html" class="sidebar-link">2.1 new Vue()时做了什么</a></li><li><a href="/./main/chapter2/2-2.html" class="sidebar-link">2.2 Vue实例挂载的实现</a></li><li><a href="/./main/chapter2/2-3.html" class="sidebar-link">2.3 Vue挂载时的mountComponent</a></li><li><a href="/./main/chapter2/2-4.html" class="sidebar-link">2.4 Virtual DOM</a></li><li><a href="/./main/chapter2/2-5.html" class="sidebar-link">2.5 最终的挂载方法_update</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第三章 组件化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter3/3-1.html" class="sidebar-link">3.1 创建组件vnode</a></li><li><a href="/./main/chapter3/3-2.html" class="sidebar-link">3.2组件的patch过程</a></li><li><a href="/./main/chapter3/3-3.html" class="sidebar-link">3.3合并配置</a></li><li><a href="/./main/chapter3/3-4.html" class="sidebar-link">3.4生命周期（上）</a></li><li><a href="/./main/chapter3/3-5.html" class="sidebar-link">3.5生命周期（下）</a></li><li><a href="/./main/chapter3/3-6.html" class="sidebar-link">3.6组件的注册</a></li><li><a href="/./main/chapter3/3-7.html" class="sidebar-link">3.7 异步组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第四章 响应式原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter4/4-1.html" class="sidebar-link">4.1 响应式对象</a></li><li><a href="/./main/chapter4/4-2.html" class="sidebar-link">4.2 依赖收集（上）</a></li><li><a href="/./main/chapter4/4-3.html" class="sidebar-link">4.3 依赖收集（下）</a></li><li><a href="/./main/chapter4/4-4.html" class="sidebar-link">4.4 派发更新</a></li><li><a href="/./main/chapter4/4-5.html" class="sidebar-link">4.5 nextTick</a></li><li><a href="/./main/chapter4/4-6.html" class="sidebar-link">4.6 检测变化的坑</a></li><li><a href="/./main/chapter4/4-7.html" class="sidebar-link">4.7 计算属性</a></li><li><a href="/./main/chapter4/4-8.html" class="sidebar-link">4.8 侦听器</a></li><li><a href="/./main/chapter4/4-9.html" aria-current="page" class="active sidebar-link">4.9 组件更新</a></li><li><a href="/./main/chapter4/4-10.html" class="sidebar-link">4.10 diff算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter5/5-1.html" class="sidebar-link">5.1 初探编译器</a></li><li><a href="/./main/chapter5/5-2.html" class="sidebar-link">5.2 从入口开始</a></li><li><a href="/./main/chapter5/5-3.html" class="sidebar-link">5.3 parse之解析模板（上）</a></li><li><a href="/./main/chapter5/5-4.html" class="sidebar-link">5.4 parse之解析模板（下）</a></li><li><a href="/./main/chapter5/5-5.html" class="sidebar-link">5.5 parse之生成AST（1）</a></li><li><a href="/./main/chapter5/5-6.html" class="sidebar-link">5.6 parse之生成AST（2）</a></li><li><a href="/./main/chapter5/5-7.html" class="sidebar-link">5.7 parse之生成AST（3）</a></li><li><a href="/./main/chapter5/5-8.html" class="sidebar-link">5.8 parse之生成AST（4）</a></li><li><a href="/./main/chapter5/5-9.html" class="sidebar-link">5.9 parse之生成AST（5）</a></li><li><a href="/./main/chapter5/5-10.html" class="sidebar-link">5.10 optimize优化</a></li><li><a href="/./main/chapter5/5-11.html" class="sidebar-link">5.11 generate代码生成（1）</a></li><li><a href="/./main/chapter5/5-12.html" class="sidebar-link">5.12 generate代码生成（2）</a></li><li><a href="/./main/chapter5/5-13.html" class="sidebar-link">5.11 generate代码生成（3）</a></li><li><a href="/./main/chapter5/5-14.html" class="sidebar-link">5.11 generate代码生成（4）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter6/6-1.html" class="sidebar-link">6.1 events（1）</a></li><li><a href="/./main/chapter6/6-2.html" class="sidebar-link">6.1 events（2）</a></li><li><a href="/./main/chapter6/6-3.html" class="sidebar-link">6.1 events（3）</a></li><li><a href="/./main/chapter6/6-4.html" class="sidebar-link">6.1 events（4）</a></li><li><a href="/./main/chapter6/6-5.html" class="sidebar-link">6.5 v-model（1）</a></li><li><a href="/./main/chapter6/6-6.html" class="sidebar-link">6.6 v-model（3）</a></li><li><a href="/./main/chapter6/6-7.html" class="sidebar-link">6.7v-model（3）</a></li><li><a href="/./main/chapter6/6-8.html" class="sidebar-link">6.8v-model（4）</a></li><li><a href="/./main/chapter6/6-9.html" class="sidebar-link">6.9 slot（上）</a></li><li><a href="/./main/chapter6/6-10.html" class="sidebar-link">6.10 slot（中）</a></li><li><a href="/./main/chapter6/6-11.html" class="sidebar-link">6.11 slot（下）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 内置组件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter7/7-1.html" class="sidebar-link">7.1 keep-alive（上）</a></li><li><a href="/./main/chapter7/7-2.html" class="sidebar-link">7.2 keep-alive（下）</a></li><li><a href="/./main/chapter7/7-3.html" class="sidebar-link">7.3 transition（上）</a></li><li><a href="/./main/chapter7/7-4.html" class="sidebar-link">7.4 transition（中）</a></li><li><a href="/./main/chapter7/7-5.html" class="sidebar-link">7.5 transition（下）</a></li><li><a href="/./main/chapter7/7-6.html" class="sidebar-link">7.6 transition-group</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第八章 Vue-router</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter8/8-1.html" class="sidebar-link">8.1 vue-router的注册</a></li><li><a href="/./main/chapter8/8-2.html" class="sidebar-link">8.2 VueRouter实例化</a></li><li><a href="/./main/chapter8/8-3.html" class="sidebar-link">8.3 动态路由</a></li><li><a href="/./main/chapter8/8-4.html" class="sidebar-link">8.4 match</a></li><li><a href="/./main/chapter8/8-5.html" class="sidebar-link">8.5 导航守卫（上）</a></li><li><a href="/./main/chapter8/8-6.html" class="sidebar-link">8.5 导航守卫（中）</a></li><li><a href="/./main/chapter8/8-7.html" class="sidebar-link">8.5 导航守卫（下）</a></li><li><a href="/./main/chapter8/8-8.html" class="sidebar-link">8.8 路径切换</a></li><li><a href="/./main/chapter8/8-9.html" class="sidebar-link">8.9 router-view组件</a></li><li><a href="/./main/chapter8/8-10.html" class="sidebar-link">8.10 router-link组件</a></li><li><a href="/./main/chapter8/8-11.html" class="sidebar-link">8.11 history模式</a></li></ul></section></li><li><a href="/./main/finish.html" class="sidebar-link">结束感言</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_4-9-组件更新"><a href="#_4-9-组件更新" class="header-anchor">#</a> 4.9 组件更新</h1> <p>  在派发更新那一小节我们讲解了数据更新后会通知渲染<code>watcher</code>，渲染<code>watcher</code>执行<code>get</code>函数进而执行其<code>getter</code>方法，<code>getter</code>其实就是<code>updateComponent</code>，我们再回顾一下 在<code>mountComponent</code>方法中创建渲染<code>watcher</code>过程：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeUpdate'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* isRenderWatcher */</span><span class="token punctuation">)</span>
</code></pre></div><p>  它传入的第二个参数<code>updateComponent</code>方法就是渲染<code>watcher</code>的<code>getter</code>函数，我们再来看<code>updateComponent</code>定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>  这一块我们应该十分熟悉，其实就是我们的挂载过程中执行的逻辑，而组件更新其实就是重新执行了一次挂载逻辑，这个过程会重新执行<code>vm._render</code>方法，然后执行<code>vm._update</code>方法，如果完全复制一次挂载过程那就会造成很多不必要的性能浪费，因为我们修改数据可能影响的只是组件中的一小部分内容，如果因此重新渲染整个组件是没有必要的。我们只需要找到更新后内容与更新前差异的地方，然后把差异修正过来就可以了。<br>
  这个过程也十分简单，我们只需要对比更新前后<code>vnode</code>的差异就可以找到哪些地方被更新了，然后我们补齐这个差异，这个过程有一个生动的名字'打补丁'，其实代码很多命名方式都是来源于生活中的其他事物。当然我们不会用中文去命名一个方法，它的英文名我们也非常熟悉，就是我们的<code>patch</code>方法。我们挂载过程也是通过这个方法的，挂载过程我们可以认为是一个从无到有的打补丁过程。<br>
  到这里其实也很明朗了，在更新时<code>patch</code>方法执行了一些不同于挂载时的逻辑，事实上在挂载过程中也不需要考虑新旧节点的差异，因为没有旧节点，可以说都是差异。我们之前在分析<code>patch</code>过程中也跳过了很多逻辑，所以我们这里就来补全这部分逻辑。<br>
  在这之前我们先来简单回顾一下<code>vm._update()</code>逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode
  <span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode
  <span class="token comment">// Vue.prototype.__patch__ is injected in entry points</span>
  <span class="token comment">// based on the rendering backend used.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// initial render</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// updates</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  这部分逻辑节选自<code>_update</code>方法中的逻辑，这里获取了旧的<code>vnode</code>，即<code>vm._vnode</code>，它的赋值其实就在下方。每次执行<code>_update</code>时都会将<code>vm._vnode</code>替换为最新的<code>vnode</code>，在更新阶段初始<code>vm._vnode</code>不为空，也就是旧的<code>vnode</code>，所以我们这里<code>preVnode</code>是有值的，这会影响我们下面逻辑。<br>
  当<code>!prevVnode为true</code>时执行的是挂载逻辑，我们第二章就已经分析过了，这里因为<code>prevVnode</code>存在所以走<code>else</code>逻辑，它同样执行的是<code>vm.__patch__</code>方法，但是传入参数不一样，在更新时会传入第一个参数<code>oldVnode</code>，其他时候会传入一个真实<code>dom</code>或者空值。下面我们来看更新时的<code>patch</code>过程。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRealElement <span class="token operator">&amp;&amp;</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// patch existing root node</span>
  <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  在<code>patch</code>方法中有这样一段逻辑，这里判断旧节点不是一个真实<code>dom</code>并且新旧<code>vnode</code>相同的话，就执行<code>patchVnode</code>方法去更新现有节点。这里的相同不是指完全相同，而是满足几个条件就可以了，我们来看<code>sameVnode</code>方法是如何定义的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    a<span class="token punctuation">.</span>key <span class="token operator">===</span> b<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span>
    a<span class="token punctuation">.</span>asyncFactory <span class="token operator">===</span> b<span class="token punctuation">.</span>asyncFactory <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
      <span class="token punctuation">(</span>
        a<span class="token punctuation">.</span>tag <span class="token operator">===</span> b<span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span>
        a<span class="token punctuation">.</span>isComment <span class="token operator">===</span> b<span class="token punctuation">.</span>isComment <span class="token operator">&amp;&amp;</span>
        <span class="token function">isDef</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">isDef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">sameInputType</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>
        <span class="token function">isTrue</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>isAsyncPlaceholder<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">isUndef</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>asyncFactory<span class="token punctuation">.</span>error<span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  sameVnode方法就定义在<code>patch.js</code>开头，首先要满足新旧<code>vnode</code>有相同的<code>key</code>值，然后判断新旧<code>asyncFactory</code>是否相同，关于<code>asyncFactory</code>我们在异步组件中分析过了。如果这两个条件都满足我们再去判断两部分内容。第一部分是判断<code>tag</code>值要相同，也就是要保证是相同元素标签，然后<code>isComment</code>属性也要相同，要是注释节点就都是注释节点。<code>data</code>配置要存在的话就都要存在，否则就都不存在，最后要判断<code>input</code>标签的<code>type</code>属性是不是相同；第二部分则判断<code>isAsyncPlaceholder</code>是否为<code>true</code>并且<code>asyncFactory</code>的<code>error</code>属性是<code>undefined</code>才行，这两个判断比较少见，所以我们没有必要深入分析它们，<code>isAsyncPlaceholder</code>在服务端渲染才可能为<code>true</code>。这两个部分是或的关系，只要有一处为真就可以了。<br>
  下面我们来看<code>sameInputType</code>方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sameInputType</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>tag <span class="token operator">!==</span> <span class="token string">'input'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token keyword">let</span> i
  <span class="token keyword">const</span> typeA <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> a<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">.</span>type
  <span class="token keyword">const</span> typeB <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> b<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">.</span>type
  <span class="token keyword">return</span> typeA <span class="token operator">===</span> typeB <span class="token operator">||</span> <span class="token function">isTextInputType</span><span class="token punctuation">(</span>typeA<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isTextInputType</span><span class="token punctuation">(</span>typeB<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这个方法定义比较简单，首先如果不是一个<code>input</code>的标签直接返回<code>true</code>就好了，否则的话就获取新旧<code>vnode.data</code>，如果<code>data</code>存在再看<code>data</code>中有没有定义<code>attrs</code>，如果有定义再看<code>attrs</code>上有没有<code>type</code>属性，分别获取新旧<code>vnode</code>的<code>type</code>，然后判断<code>type</code>是否相同或者两个<code>type</code>同时满足<code>isTextInputType</code>，<code>isTextInputType</code>定义再<code>platform/web/util/element.js</code>中</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> isTextInputType <span class="token operator">=</span> <span class="token function">makeMap</span><span class="token punctuation">(</span><span class="token string">'text,number,password,search,email,tel,url'</span><span class="token punctuation">)</span>
</code></pre></div><p>  因为<code>input</code>元素类型比较多，不同<code>type</code>表现完全不同，可以表现为不同的元素，但是对于输入框，<code>type</code>有多种类型，这里通过<code>makeMap</code>构建一个校验<code>type</code>是否是输入框类型函数。如果两个<code>type</code>都属于上述类型一种，那么也可以认为它们是相同的类型。<br>
  回到<code>patch</code>中，如果判断两个节点相同的话就执行<code>patchVnode</code>，这个方法是用来更新现有根节点的，因为新节点没有改变的话，就没必要去重新挂载<code>dom</code>，只需要更新部分内容就可以了，至于为什么是根节点，因为<code>patch</code>都是组件化时候执行的，这里新旧<code>vnode</code>都是组件的根节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patchVnode</span><span class="token punctuation">(</span>
  <span class="token parameter">oldVnode<span class="token punctuation">,</span>
  vnode<span class="token punctuation">,</span>
  insertedVnodeQueue<span class="token punctuation">,</span>
  ownerArray<span class="token punctuation">,</span>
  index<span class="token punctuation">,</span>
  removeOnly</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode <span class="token operator">===</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ownerArray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// clone reused vnode</span>
    vnode <span class="token operator">=</span> ownerArray<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cloneVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> elm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>isAsyncPlaceholder<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>asyncFactory<span class="token punctuation">.</span>resolved<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">hydrate</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      vnode<span class="token punctuation">.</span>isAsyncPlaceholder <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span>省略大段逻辑
<span class="token punctuation">}</span>
</code></pre></div><p>  我们先来看<code>patchVnode</code>方法前面这段代码，首先来看它接收的三个参数，第一个参数就是旧节点<code>oldVnode</code>；第二个参数新节点<code>vnode</code>；第三个参数<code>insertedVnodeQueue</code>是插入<code>vnode</code>队列；<code>ownerArray</code>这里传入的是<code>null</code>；<code>index</code>传入也是<code>null</code>；<code>removeOnly</code>没有传入这里是<code>undefined</code>。<br>
  然后我们看函数逻辑，首先新旧<code>vnode</code>是同一个对象的话就执行<code>return</code>。接下来这段逻辑我们暂时不会用到，因为<code>vnode.elm</code>和<code>ownerArray</code>是不存在的。然后获取旧<code>vnode</code>的真实<code>dom</code>节点并赋值给<code>vnode.elm</code>和<code>elm</code>。<br>
  接下来这段逻辑关于异步占位节点，这里在服务端渲染时候才可能为<code>true</code>，所以这段逻辑我们不需要去关注他，接下来有关<code>vnode.isStatic</code>的判断也不会执行，这个内容我们会在后续章节中分析。<br>
  接着看下面代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">let</span> i
  <span class="token keyword">const</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>prepatch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">i</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> oldCh <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>children
  <span class="token keyword">const</span> ch <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isPatchable</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>update<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>update<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">i</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  接下来这个<code>if</code>判断<code>data.hook.prepactch</code>方法是否存在，存在的话就调用它，在3.1小节我们讲过生成组件<code>vnode</code>时会给其<code>data</code>添加一系列<code>hook</code>钩子，只有它是组件<code>vnode</code>时才会存在，如下所示：</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HelloWorld</span> <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>content<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HelloWorld</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>  这个时候才会走<code>prepatch</code>逻辑，这个<code>hook</code>钩子我们之前没有分析过，现在我们来看看它做了什么事。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">prepatch</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">oldVnode</span><span class="token operator">:</span> MountedComponentVNode<span class="token punctuation">,</span> <span class="token literal-property property">vnode</span><span class="token operator">:</span> MountedComponentVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentOptions
  <span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>componentInstance
  <span class="token function">updateChildComponent</span><span class="token punctuation">(</span>
    child<span class="token punctuation">,</span>
    options<span class="token punctuation">.</span>propsData<span class="token punctuation">,</span> <span class="token comment">// updated props</span>
    options<span class="token punctuation">.</span>listeners<span class="token punctuation">,</span> <span class="token comment">// updated listeners</span>
    vnode<span class="token punctuation">,</span> <span class="token comment">// new parent vnode</span>
    options<span class="token punctuation">.</span>children <span class="token comment">// new children</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这里先要获取<code>vnode.componentOptions</code>保存在<code>options</code>中，获取组件实例保存在<code>child</code>中，然后执行<code>updateChildComponent</code>方法，对于<code>updateChildComponent</code>方法这里我们只做简单的介绍，因为关于<code>slot、event、props</code>等内容我们还没有去分析。这里的<code>child</code>实际上是<code>HelloWorld</code>组件实例，也就是子组件实例，所以这个方法主要是对子组件做更新处理。<br>
  我们回到<code>patchVnode</code>函数中，接着往下看定义了<code>oldCh</code>与<code>ch</code>，也就是获取新旧<code>vnode</code>的<code>children</code>，当然这里我们的组件占位<code>vnode</code>的<code>children</code>是<code>undefined</code>。<br>
  接下来判断<code>data</code>存在且满足<code>isPatchable(vnode)</code>，<code>isPatchable</code>方法很好理解，就是能够<code>patch</code>的意思，<code>'能够patch'</code>意思是真正可以用来挂载的<code>vnode</code>，比如我们的普通<code>vnode</code>就是一个能挂载的节点，比如说一个<code>tag</code>为<code>div</code>的节点，而我们这里的组件占位<code>vnode</code>不能真正用于挂载，但是<code>isPatchable</code>方法会一直往下找直到找到可挂载节点为止。我们下面来看<code>isPatchable</code>方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isPatchable</span><span class="token punctuation">(</span><span class="token parameter">vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vnode <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">.</span>_vnode
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  当<code>vnode.componentInstance</code>存在时候就取它的<code>_vnode</code>，直到它的<code>_vnode</code>不存在<code>componentInstance</code>属性时退出循环，然后取<code>tag</code>判断是否存在，如果存在<code>tag</code>说明他是一个普通的<code>vnode</code>，也就是可以<code>patch</code>的。<br>
  满足上述条件，就依次调用<code>cbs.update</code>数组中的方法，<code>update</code>数组中的方法与平台相关的方法，如下所示：
</p><div class="center"><img src="/4.9.1.png"></div><p></p> <p>  这些方法我暂时不去讨论，再往下是执行<code>hook.update</code>方法，比较遗憾的是我没有找到它什么时候被定义和执行。</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCh <span class="token operator">!==</span> ch<span class="token punctuation">)</span> <span class="token function">updateChildren</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> oldCh<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">checkDuplicateKeys</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
        <span class="token function">addVnodes</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ch<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">removeVnodes</span><span class="token punctuation">(</span>oldCh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldCh<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>text <span class="token operator">!==</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nodeOps<span class="token punctuation">.</span><span class="token function">setTextContent</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>  
</code></pre></div><p>  继续往下分析<code>patchVnode</code>方法，当<code>vnode.text</code>不存在时会执行大段逻辑，我们先来分析<code>vnode.text</code>存在的时候，这时候如果<code>else if</code>判断新旧节点<code>text</code>值不同的话就执行<code>nodeOps.setTextContent</code>方法去修改文本节点的<code>textContent</code>。我们再回过头来看<code>isUndef(vnode.text)</code>为<code>true</code>时逻辑，然后又执行了四个<code>if</code>分支：首先如果<code>oldCh</code>和<code>ch</code>都存在的话就执行<code>updateChildren</code>方法，<code>updateChildren</code>方法定义非常复杂也就是我们所说的<code>diff</code>算法，我们在后面会专门去讲解它，这里我们简单知道它内部会递归调用<code>patchVnode</code>方法就可以了；然后再看第二个分支如果只有<code>ch</code>存在，在开发环境下执行<code>checkDuplicateKeys(ch)</code>，这个方法是对我们写的<code>key</code>做是否重复的一个检查，接着如果这时旧节点是文本节点就先将文本节点置为空，最后执行<code>addVnodes</code>方法;第三个分支是判断只有<code>oldCh</code>存在的话执行<code>removeVnodes</code>方法；最后如果新旧节点<code>children</code>都不存在的话再判断就节点是不是文本节点，如果是文本节点的话将文本置为空。<br>
  再往下判断<code>hook</code>中有没有<code>postpatch</code>方法，如果有的话就执行看，这个方法我们在之后的章节中分析。<br>
  接下来来分析上面的提到的<code>checkDuplicateKeys、addVnodes、removeVnodes</code>方法。首先来看<code>checkDuplicateKeys</code>，其实根据其命名就可以知道它是用来专门检查是否有<code>key</code>值重复的方法，我们来看源码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkDuplicateKeys</span><span class="token punctuation">(</span><span class="token parameter">children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> seenKeys <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vnode <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> vnode<span class="token punctuation">.</span>key
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>seenKeys<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">warn</span><span class="token punctuation">(</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Duplicate keys detected: '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'. This may cause an update error.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
          vnode<span class="token punctuation">.</span>context
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        seenKeys<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  就是遍历子节点并检查是否有相同的<code>key</code>存在，如果<code>key</code>为<code>undefined</code>则不做判断，这在我们<code>v-for</code>循环中比较常用，它报的警告也是非常常见的，这个方法比较简单我们就不做详细分析了。<br>
  然后是<code>addVnodes</code>方法，我们来看源码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">addVnodes</span><span class="token punctuation">(</span><span class="token parameter">parentElm<span class="token punctuation">,</span> refElm<span class="token punctuation">,</span> vnodes<span class="token punctuation">,</span> startIdx<span class="token punctuation">,</span> endIdx<span class="token punctuation">,</span> insertedVnodeQueue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> startIdx <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>startIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">createElm</span><span class="token punctuation">(</span>vnodes<span class="token punctuation">[</span>startIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> refElm<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> vnodes<span class="token punctuation">,</span> startIdx<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  addVnodes方法其实是用来添加新节点的，实际上就是把遍历子<code>vnode</code>数组根据传入遍历的起始索引<code>startIdx</code>和结束索引<code>endIdx</code>去循环执行<code>createElm</code>方法去创建并插入节点。<br>
  然后我们看<code>removeVnodes</code>源码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">removeVnodes</span><span class="token punctuation">(</span><span class="token parameter">vnodes<span class="token punctuation">,</span> startIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> startIdx <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>startIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> ch <span class="token operator">=</span> vnodes<span class="token punctuation">[</span>startIdx<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>ch<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">removeAndInvokeRemoveHook</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
        <span class="token function">invokeDestroyHook</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// Text node</span>
        <span class="token function">removeNode</span><span class="token punctuation">(</span>ch<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  显然这是一个移除方法，遍历旧的子<code>vnode</code>数组，如果存在<code>tag</code>就执行下面两个钩子函数，我们来看<code>removeAndInvokeRemoveHook</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">removeAndInvokeRemoveHook</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> rm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>rm<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">removeNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这个方法定义看起来非常复杂，但是<code>if</code>分支逻辑没有执行，因为这里没有传入第二个参数<code>rm</code>，所以我们只看<code>else</code>逻辑就是执行<code>removeNode</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code>	<span class="token keyword">function</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> parent <span class="token operator">=</span> nodeOps<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
    <span class="token comment">// element may have already been removed due to v-html / v-text</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nodeOps<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> el<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  removeNode方法就是先获取传入节点的父节点，再调用<code>removeChild</code>方法去移除子节点，上面一行注释意思是因为<code>v-html/v-text</code>，元素可能已经被删除了。<br>
  再回到<code>removeVnodes</code>方法中，我们来看<code>invokeDestroyHook</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">invokeDestroyHook</span><span class="token punctuation">(</span><span class="token parameter">vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> j
  <span class="token keyword">const</span> data <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>destroy<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">i</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>destroy<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>destroy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">invokeDestroyHook</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  该方法主要是执行一些<code>destroy</code>钩子，包括<code>hook.destroy</code>，还有<code>cbs</code>中的<code>destroy</code>方法，如果<code>vnode</code>还存在子节点的话，就递归调用<code>invokeDestoryHook</code>将子节点销毁。再来看<code>hook.destory</code>的定义：</p> <div class="language-js extra-class"><pre class="language-js"><code>	<span class="token function">destroy</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vnode</span><span class="token operator">:</span> MountedComponentVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> componentInstance <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>componentInstance<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        componentInstance<span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">deactivateChildComponent</span><span class="token punctuation">(</span>componentInstance<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* direct */</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  destroy钩子比较简单获取组件实例，如果组件没有被销毁则判断是否是组件是否被<code>keepAlive</code>缓存，如果没有被缓存则调用<code>$destroy()</code>方法，这个方法就是销毁组件的方法，我们在3.5小节有提到，这里就不在赘述了。然后如果组件被<code>keep-alive</code>缓存的话就执行<code>else</code>逻辑，我们来看<code>deactivateChildComponent</code>方法，该方法定义于<code>lifecycle.js</code>文件下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">deactivateChildComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component<span class="token punctuation">,</span> direct<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>direct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_directInactive <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInInactiveTree</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">.</span>_inactive<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_inactive <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vm<span class="token punctuation">.</span>$children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">deactivateChildComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'deactivated'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  该方法接收两个参数，一个是组件实例<code>vm</code>，另一个参数<code>direct</code>这里传入的是<code>true</code>，当<code>direct</code>为<code>true</code>时将<code>vm._directInactive</code>设置为<code>true</code>，如果<code>isInInactiveTree</code>为<code>true</code>就直接<code>return</code>，<code>isInInativeTree</code>方法如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isInInactiveTree</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>vm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>vm <span class="token operator">=</span> vm<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_inactive<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  isInInactiveTree方法定义比较简单，自下而上寻找父组件实例，直到父组件的<code>_inactive</code>为<code>true</code>位置，<code>inactive</code>是不活跃的意思，因为被缓存组件卸载时不会销毁组件实例，而是会被打上一个不活跃的标签，这个方法是用来检测组件在不在一个不活跃<code>tree</code>上，如果它的父级已经是非活跃的就不需要再对其做处理了。<br>
  如果<code>isInInactiveTree(vm)</code>为<code>false</code>则继续往下执行，先将组件<code>_inactive</code>置为<code>true</code>，再遍历<code>vm.$children</code>数组并递归调用<code>deactivateChildComponent</code>，可以注意到递归时没有传入第二参数，如果传入第二参数为<code>true</code>递归就没有意义了。代码逻辑是比较简单的，但是这里设计思路是比较难猜的，等我们后面分析完<code>keep-alive</code>的实现也许就清晰了。<br>
  继续回到<code>removeVnodes</code>的方法，如果<code>ch.tag</code>不存在那就是文本节点了，直接调用<code>removeNode</code>方法就可以了。<br>
  最后回到我们<code>patchVnode</code>方法中来看最后一段逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>postpatch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">i</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  当<code>data.hook.postpatch</code>方法存在时执行<code>postpatch</code>方法，这可能是与指令相关的逻辑，因为我在<code>vdom/modules/directives.js</code>中找到了它。关于指令的我们还没有去分析它，所以这部分内容我们暂时略过。</p> <p>  到这里我们就将组件更新时对相同节点的处理讲解完了，组件更新时的<code>patch</code>其实是有两个分支的，我们上面分析的是相同节点的更新，那么下面我们来分析不同节点的更新过程。不同节点的更新大致可以分为三个过程：创建新节点、更新父节点、删除旧节点。
我们先写个小dome来说明不同节点的更新：</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>content === 'I am content'<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    {{ content }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-else</span><span class="token punctuation">&gt;</span></span>{{ content }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">'I am content'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> <span class="token string">'I am updated'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>同样是一个非常简单的小例子，通过<code>v-if</code>来控制节点的显示与隐藏，当<code>content</code>修改时<code>div</code>标签会变成<code>p</code>标签，这样就实现了不同节点的转换。
下面我们来看源码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRealElement <span class="token operator">&amp;&amp;</span> <span class="token function">sameVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// patch existing root node</span>
  <span class="token function">patchVnode</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> removeOnly<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRealElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// replacing existing element</span>
  <span class="token keyword">const</span> oldElm <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>elm
  <span class="token keyword">const</span> parentElm <span class="token operator">=</span> nodeOps<span class="token punctuation">.</span><span class="token function">parentNode</span><span class="token punctuation">(</span>oldElm<span class="token punctuation">)</span>

  <span class="token comment">// create new node 将Vnode挂载到DOM</span>
  <span class="token function">createElm</span><span class="token punctuation">(</span>
    vnode<span class="token punctuation">,</span>
    insertedVnodeQueue<span class="token punctuation">,</span>
    <span class="token comment">// extremely rare edge case: do not insert if old element is in a</span>
    <span class="token comment">// leaving transition. Only happens when combining transition +</span>
    <span class="token comment">// keep-alive + HOCs. (#4590)</span>
    oldElm<span class="token punctuation">.</span>_leaveCb <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> parentElm<span class="token punctuation">,</span>
    nodeOps<span class="token punctuation">.</span><span class="token function">nextSibling</span><span class="token punctuation">(</span>oldElm<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
	<span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  上面<code>else</code>逻辑就是对不同节点的处理逻辑，显然更新时<code>isRealElement</code>为<code>false</code>，只有首次渲染时挂载根组件时才是一个真实<code>dom</code>，所以这里我们不会执行<code>if</code>里面的逻辑，然后我们接着往下看，首先定义<code>oldElm</code>来保存<code>oldVnode.elm</code>，也就是旧的<code>dom</code>节点，然后再去找它的父节点保存在<code>parentElm</code>中，然后还是调用<code>createElm</code>去创建新节点并找到它正确的插入位置插入元素。<br>
  然后我们继续往下看源码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// update parent placeholder node element, recursively</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">let</span> ancestor <span class="token operator">=</span> vnode<span class="token punctuation">.</span>parent
<span class="token keyword">const</span> patchable <span class="token operator">=</span> <span class="token function">isPatchable</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>ancestor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>destroy<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cbs<span class="token punctuation">.</span>destroy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>ancestor<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    ancestor<span class="token punctuation">.</span>elm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>elm
    <span class="token keyword">if</span> <span class="token punctuation">(</span>patchable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>create<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cbs<span class="token punctuation">.</span>create<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>emptyNode<span class="token punctuation">,</span> ancestor<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// #6513</span>
      <span class="token comment">// invoke insert hooks that may have been merged by create 			hooks.</span>
      <span class="token comment">// e.g. for directives that uses the &quot;inserted&quot; hook.</span>
      <span class="token keyword">const</span> insert <span class="token operator">=</span> ancestor<span class="token punctuation">.</span>data<span class="token punctuation">.</span>hook<span class="token punctuation">.</span>insert
      <span class="token keyword">if</span> <span class="token punctuation">(</span>insert<span class="token punctuation">.</span>merged<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// start at index 1 to avoid re-invoking component 					mounted hook</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> insert<span class="token punctuation">.</span>fns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              insert<span class="token punctuation">.</span>fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">registerRef</span><span class="token punctuation">(</span>ancestor<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    ancestor <span class="token operator">=</span> ancestor<span class="token punctuation">.</span>parent
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这部分逻辑主要是为了更新父的占位节点，先判断<code>vnode.parent</code>是否存在，在更新时父占位节点肯定是存在的，其实就是父的占位节点，然后把它保存在<code>ancestor</code>变量中，然后通过<code>isPatchable(vnode)</code>方法去找<code>vnode</code>是否有可挂载节点，这个方法我们上面已经分析过了，如果找到可挂载节点的话它会返回<code>true</code>。存在父占位节点的话执行<code>while</code>循环，为什么用<code>while</code>循环呢？这就要从<code>vnode.parent</code>的来源说起，在<code>render.js</code>文件下的<code>Vue.prototype._render</code>方法定义中最后一段逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> _parentVnode <span class="token punctuation">}</span> <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
vnode<span class="token punctuation">.</span>parent <span class="token operator">=</span> _parentVnode
</code></pre></div><p>  这是目前我们唯一值已知的对<code>vnode.parent</code>赋值的地方，回顾我们第三章组件化中的内容。我们上什么时候会执行<code>vm._render</code>，挂载根组件时就不用说了，我们说挂载子组件是递归调用<code>vm._init()</code>和<code>vm.$mount</code>的过程，也就是说每次挂载子组件都会调用<code>vm._render</code>。那么什么时候会挂载子组件呢？父组件<code>patch</code>过程中会依次插入子<code>vnode</code>，当它<code>patch</code>到一种特殊的<code>vnode</code>————占位<code>vnode</code>时，发现这个<code>vnode</code>应该放一个子组件，所以就靠占位<code>vnode</code>中的信息去初始化子组件，我们前面一直称这个<code>vnode</code>是子组件的父占位节点，它的作用就是在父组件中占位。也就是<code>patch</code>到占位<code>vnode</code>时，会递归地调用<code>vm._init()</code>和<code>vm.$mount</code>，在<code>_init</code>调用时将占位<code>vnode</code>作为<code>options</code>的<code>_parentVode</code>属性传入，经过合并选项后<code>vm.$options</code>中就保留了<code>_parentVode</code>。<code>vm._render</code>方法生成的组件<code>vnode</code>其实是组件根节点的<code>vnode</code>，因为在<code>vue2</code>中组件只能有一个根节点，所以生成的是单个<code>vnode</code>，最后将<code>vnode.parent</code>设置为占位<code>vnode</code>，所以组件根元素的<code>vnode</code>才有<code>parent</code>，此外根组件因为没有父组件所以它生成的根节点<code>vnode</code>也是没有<code>parent</code>的。
  了解<code>vnode.paren</code>t后我们就可以回归正题了，因为组件更新时它的占位节点也需要跟着更新，一般情况下找到<code>vnode.parent</code>更新就可以了，但是如果组件的根节点也是一个组件呢？这样的示例我们上面就已经写过了，这个时候<code>ancestor.parent</code>仍然存在，它同样也是需要更新的，所以最后把<code>ancestor</code>再赋值给<code>ancestor</code>以便于循环去更新。
我们来看执行逻辑，首先遍历调用<code>modules</code>的<code>destroy</code>钩子，<code>cbs</code>我们见过很多次了，但是我们没有具体去讲解，其实就是定义的一些公共模块和平台相关模块，如果一一去分析它们就太过繁琐，有兴趣的话可以自己去了解一下。这些模块会各自暴露一些钩子函数，一些需要销毁的模块就会暴露<code>destroy</code>钩子，比如事件监听、ref、direactive。而对class、attrs处理的一些模块就只需要创建和更新就可以了，这里是执行了一些需要销毁的模块。<br>
  然后将<code>ancestor</code>的<code>dom</code>引用更新，接着往下又是一段判断逻辑，如果<code>vnode</code>是可挂载的，就依次调用<code>cbs</code>中的<code>create</code>钩子，这里传入了<code>emptyNode</code>和<code>ancestor</code>两个参数，我们先来看<code>emptyNode</code>正如它名字一般是一个空的<code>vnode</code>，其定义如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> emptyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>	
</code></pre></div><p><code>emptyNode</code>是通过<code>new VNode</code>创建的空节点，这里创建钩子有点不好理解，因为我们是在更新占位节点，更新时调用创建钩子并且传入空的<code>vnode</code>和占位<code>vnode</code>是不符合常理的，因为我不认为占位节点还需要更新<code>attrs、class</code>，这个时候我稍微看了一下<code>attrs</code>模块的实现，才明白怎么回事。因为我们这里是不同节点的更新，因为根节点是不同的，<code>create</code>钩子一般是接收两个参数，分别是新旧<code>vnode</code>，因为部分模块创建和更新用的都是更新的方法，创建其实就是旧节点为空的更新，所以这里我们把就节点传入空的<code>vnode</code>，因为我们<code>attrs</code>处理模块要有对比新旧节点<code>attrs</code>属性，为了方便就传入空的<code>vnode</code>而不是什么都不传。<br>
  这里就引出了一个比较容易忽略的概念——<code>vue2</code>的非<code>props</code>特性，如果我们在组件标签上添加 <code>attribute</code>，但没有在<code>props</code>中定义，那么这个属性会继承到组件根标签上，显然之前根标签会继承父占位节点中的<code>attrs、class</code>等属性，但是这里根标签变了，正如我们示例中由<code>div</code>标签变为<code>p</code>，如果我们给组件添加了属性，那么<code>div</code>是能继承到的，而p是没有的，所以我这里<code>create</code>钩子就是为新标签添加这些属性，它是直接添加到<code>dom</code>的，因为在这之前我们更新了父占位节点<code>ancestor</code>的<code>dom</code>引用，所以<code>p</code>标签真实节点是可以从<code>ancestor</code>中拿到的，这里我们就只是以<code>attrs</code>模块为例简单分析一下，具体<code>attrs</code>以及其他模块更新实现就不在这里分析了。接下来是关于一些指令的逻辑，最后如果<code>vnode</code>不能被挂载的话就执行<code>registerRef</code>，指令和模板引用的逻辑我们就不再这里分析了。
最后再看移除旧节点逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// destroy old node</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">removeVnodes</span><span class="token punctuation">(</span><span class="token punctuation">[</span>oldVnode<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">invokeDestroyHook</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  就是简单的判断旧的<code>dom</code>有父节点的话，就调用<code>removeVnodes</code>方法移除<code>dom</code>，这个方法我们前面分析<code>patchVnode</code>时已经分析过了，这里就不再赘述了，而如果没有父节点的话说明父节点已经删除了，这时只需要调用销毁的一些钩子函数就可以了。<br>
  到这里我们组件更新分析就告一段落了，但是组件更新中一个重要环节我们还没有去分析，那就是<code>diff</code>算法，因为它比较复杂，所以我们作为一个单独的小节来分析它，那么下一小节我们就来讲解<code>diff</code>算法的实现。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./main/chapter4/4-8.html" class="prev">
        4.8 侦听器
      </a></span> <span class="next"><a href="/./main/chapter4/4-10.html">
        4.10 diff算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.d5acc79b.js" defer></script><script src="./assets/js/2.b590321b.js" defer></script><script src="./assets/js/41.aff618f5.js" defer></script>
  </body>
</html>
