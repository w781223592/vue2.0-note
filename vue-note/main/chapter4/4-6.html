<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>4.6 检测变化的坑 | 卷心菜笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./logo.jpg">
    <meta name="description" content="基于vue@2.6.14的学习笔记">
    
    <link rel="preload" href="./assets/css/0.styles.34509ede.css" as="style"><link rel="preload" href="./assets/js/app.cb86b5c8.js" as="script"><link rel="preload" href="./assets/js/2.8a65079d.js" as="script"><link rel="preload" href="./assets/js/41.1b14daa9.js" as="script"><link rel="prefetch" href="./assets/js/10.35fa5c54.js"><link rel="prefetch" href="./assets/js/11.a8d301ee.js"><link rel="prefetch" href="./assets/js/12.28dadb6d.js"><link rel="prefetch" href="./assets/js/13.959f52a9.js"><link rel="prefetch" href="./assets/js/14.9e967e5c.js"><link rel="prefetch" href="./assets/js/15.89c1bf18.js"><link rel="prefetch" href="./assets/js/16.78f7cadf.js"><link rel="prefetch" href="./assets/js/17.eee5b860.js"><link rel="prefetch" href="./assets/js/18.e94d03e8.js"><link rel="prefetch" href="./assets/js/19.c9b980d9.js"><link rel="prefetch" href="./assets/js/20.82c7f25f.js"><link rel="prefetch" href="./assets/js/21.5878b705.js"><link rel="prefetch" href="./assets/js/22.e7794d4a.js"><link rel="prefetch" href="./assets/js/23.b1e09bbf.js"><link rel="prefetch" href="./assets/js/24.e1df98bf.js"><link rel="prefetch" href="./assets/js/25.1c2fb721.js"><link rel="prefetch" href="./assets/js/26.36c3f7e0.js"><link rel="prefetch" href="./assets/js/27.a3f09949.js"><link rel="prefetch" href="./assets/js/28.123d6383.js"><link rel="prefetch" href="./assets/js/29.04a6e255.js"><link rel="prefetch" href="./assets/js/3.3554c1dd.js"><link rel="prefetch" href="./assets/js/30.f5e711c8.js"><link rel="prefetch" href="./assets/js/31.7ddb232a.js"><link rel="prefetch" href="./assets/js/32.3710a144.js"><link rel="prefetch" href="./assets/js/33.836eb573.js"><link rel="prefetch" href="./assets/js/34.c3f3eb0f.js"><link rel="prefetch" href="./assets/js/35.3e97ba3f.js"><link rel="prefetch" href="./assets/js/36.0ff1be33.js"><link rel="prefetch" href="./assets/js/37.57e976da.js"><link rel="prefetch" href="./assets/js/38.778b591d.js"><link rel="prefetch" href="./assets/js/39.f89500e6.js"><link rel="prefetch" href="./assets/js/4.414ef3ae.js"><link rel="prefetch" href="./assets/js/40.0bb1a72b.js"><link rel="prefetch" href="./assets/js/42.da61de9e.js"><link rel="prefetch" href="./assets/js/43.afa151ce.js"><link rel="prefetch" href="./assets/js/44.beed5647.js"><link rel="prefetch" href="./assets/js/45.15cb664e.js"><link rel="prefetch" href="./assets/js/46.19b76064.js"><link rel="prefetch" href="./assets/js/47.81dd06b3.js"><link rel="prefetch" href="./assets/js/48.da28ae74.js"><link rel="prefetch" href="./assets/js/49.6ec02c7d.js"><link rel="prefetch" href="./assets/js/5.7771716e.js"><link rel="prefetch" href="./assets/js/50.33adc7e6.js"><link rel="prefetch" href="./assets/js/51.ad4dcf8f.js"><link rel="prefetch" href="./assets/js/52.1f63a577.js"><link rel="prefetch" href="./assets/js/53.f08905cc.js"><link rel="prefetch" href="./assets/js/54.95edb54c.js"><link rel="prefetch" href="./assets/js/55.4ad5a772.js"><link rel="prefetch" href="./assets/js/56.d55c7dcb.js"><link rel="prefetch" href="./assets/js/57.2bdbd5d4.js"><link rel="prefetch" href="./assets/js/58.6996ec46.js"><link rel="prefetch" href="./assets/js/59.42c770e8.js"><link rel="prefetch" href="./assets/js/6.f0272f8f.js"><link rel="prefetch" href="./assets/js/60.9a43de0b.js"><link rel="prefetch" href="./assets/js/61.9fda2ee3.js"><link rel="prefetch" href="./assets/js/62.40ba97a6.js"><link rel="prefetch" href="./assets/js/63.a8ceda24.js"><link rel="prefetch" href="./assets/js/64.063b5356.js"><link rel="prefetch" href="./assets/js/65.609bfe39.js"><link rel="prefetch" href="./assets/js/66.10bbf1b3.js"><link rel="prefetch" href="./assets/js/67.ed6fbab5.js"><link rel="prefetch" href="./assets/js/68.edf47e53.js"><link rel="prefetch" href="./assets/js/69.58c89969.js"><link rel="prefetch" href="./assets/js/7.44545bae.js"><link rel="prefetch" href="./assets/js/70.44d1903b.js"><link rel="prefetch" href="./assets/js/71.f54eb805.js"><link rel="prefetch" href="./assets/js/72.e0f8bc14.js"><link rel="prefetch" href="./assets/js/73.2292a46a.js"><link rel="prefetch" href="./assets/js/74.259c6d32.js"><link rel="prefetch" href="./assets/js/75.a5535961.js"><link rel="prefetch" href="./assets/js/76.2e270b76.js"><link rel="prefetch" href="./assets/js/77.a4bffe25.js"><link rel="prefetch" href="./assets/js/78.e00f48eb.js"><link rel="prefetch" href="./assets/js/79.dd1ef766.js"><link rel="prefetch" href="./assets/js/8.54165142.js"><link rel="prefetch" href="./assets/js/80.6d018d78.js"><link rel="prefetch" href="./assets/js/81.8647d108.js"><link rel="prefetch" href="./assets/js/82.9c326a94.js"><link rel="prefetch" href="./assets/js/83.0a8e8403.js"><link rel="prefetch" href="./assets/js/84.e1f731e8.js"><link rel="prefetch" href="./assets/js/85.446cc3ec.js"><link rel="prefetch" href="./assets/js/86.7800fc8e.js"><link rel="prefetch" href="./assets/js/87.51a4cddc.js"><link rel="prefetch" href="./assets/js/88.5cb86311.js"><link rel="prefetch" href="./assets/js/89.11fe5589.js"><link rel="prefetch" href="./assets/js/9.2a932dde.js"><link rel="prefetch" href="./assets/js/90.b3555572.js">
    <link rel="stylesheet" href="./assets/css/0.styles.34509ede.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">卷心菜笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/./main/" aria-current="page" class="sidebar-link">前言</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 初识Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter1/1-1.html" class="sidebar-link">1.1 Vue目录设计</a></li><li><a href="/./main/chapter1/1-2.html" class="sidebar-link">1.2 Vue入口文件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 Vue初始化和挂载</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter2/2-1.html" class="sidebar-link">2.1 new Vue()时做了什么</a></li><li><a href="/./main/chapter2/2-2.html" class="sidebar-link">2.2 Vue实例挂载的实现</a></li><li><a href="/./main/chapter2/2-3.html" class="sidebar-link">2.3 Vue挂载时的mountComponent</a></li><li><a href="/./main/chapter2/2-4.html" class="sidebar-link">2.4 Virtual DOM</a></li><li><a href="/./main/chapter2/2-5.html" class="sidebar-link">2.5 最终的挂载方法_update</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第三章 组件化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter3/3-1.html" class="sidebar-link">3.1 创建组件vnode</a></li><li><a href="/./main/chapter3/3-2.html" class="sidebar-link">3.2组件的patch过程</a></li><li><a href="/./main/chapter3/3-3.html" class="sidebar-link">3.3合并配置</a></li><li><a href="/./main/chapter3/3-4.html" class="sidebar-link">3.4生命周期（上）</a></li><li><a href="/./main/chapter3/3-5.html" class="sidebar-link">3.5生命周期（下）</a></li><li><a href="/./main/chapter3/3-6.html" class="sidebar-link">3.6组件的注册</a></li><li><a href="/./main/chapter3/3-7.html" class="sidebar-link">3.7 异步组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第四章 响应式原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter4/4-1.html" class="sidebar-link">4.1 响应式对象</a></li><li><a href="/./main/chapter4/4-2.html" class="sidebar-link">4.2 依赖收集（上）</a></li><li><a href="/./main/chapter4/4-3.html" class="sidebar-link">4.3 依赖收集（下）</a></li><li><a href="/./main/chapter4/4-4.html" class="sidebar-link">4.4 派发更新</a></li><li><a href="/./main/chapter4/4-5.html" class="sidebar-link">4.5 nextTick</a></li><li><a href="/./main/chapter4/4-6.html" aria-current="page" class="active sidebar-link">4.6 检测变化的坑</a></li><li><a href="/./main/chapter4/4-7.html" class="sidebar-link">4.7 计算属性</a></li><li><a href="/./main/chapter4/4-8.html" class="sidebar-link">4.8 侦听器</a></li><li><a href="/./main/chapter4/4-9.html" class="sidebar-link">4.9 组件更新</a></li><li><a href="/./main/chapter4/4-10.html" class="sidebar-link">4.10 diff算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter5/5-1.html" class="sidebar-link">5.1 初探编译器</a></li><li><a href="/./main/chapter5/5-2.html" class="sidebar-link">5.2 从入口开始</a></li><li><a href="/./main/chapter5/5-3.html" class="sidebar-link">5.3 parse之解析模板（上）</a></li><li><a href="/./main/chapter5/5-4.html" class="sidebar-link">5.4 parse之解析模板（下）</a></li><li><a href="/./main/chapter5/5-5.html" class="sidebar-link">5.5 parse之生成AST（1）</a></li><li><a href="/./main/chapter5/5-6.html" class="sidebar-link">5.6 parse之生成AST（2）</a></li><li><a href="/./main/chapter5/5-7.html" class="sidebar-link">5.7 parse之生成AST（3）</a></li><li><a href="/./main/chapter5/5-8.html" class="sidebar-link">5.8 parse之生成AST（4）</a></li><li><a href="/./main/chapter5/5-9.html" class="sidebar-link">5.9 parse之生成AST（5）</a></li><li><a href="/./main/chapter5/5-10.html" class="sidebar-link">5.10 optimize优化</a></li><li><a href="/./main/chapter5/5-11.html" class="sidebar-link">5.11 generate代码生成（1）</a></li><li><a href="/./main/chapter5/5-12.html" class="sidebar-link">5.12 generate代码生成（2）</a></li><li><a href="/./main/chapter5/5-13.html" class="sidebar-link">5.13 generate代码生成（3）</a></li><li><a href="/./main/chapter5/5-14.html" class="sidebar-link">5.14 generate代码生成（4）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter6/6-1.html" class="sidebar-link">6.1 events（1）</a></li><li><a href="/./main/chapter6/6-2.html" class="sidebar-link">6.2 events（2）</a></li><li><a href="/./main/chapter6/6-3.html" class="sidebar-link">6.3 events（3）</a></li><li><a href="/./main/chapter6/6-4.html" class="sidebar-link">6.4 events（4）</a></li><li><a href="/./main/chapter6/6-5.html" class="sidebar-link">6.5 v-model（1）</a></li><li><a href="/./main/chapter6/6-6.html" class="sidebar-link">6.6 v-model（2）</a></li><li><a href="/./main/chapter6/6-7.html" class="sidebar-link">6.7v-model（3）</a></li><li><a href="/./main/chapter6/6-8.html" class="sidebar-link">6.8v-model（4）</a></li><li><a href="/./main/chapter6/6-9.html" class="sidebar-link">6.9 slot（上）</a></li><li><a href="/./main/chapter6/6-10.html" class="sidebar-link">6.10 slot（中）</a></li><li><a href="/./main/chapter6/6-11.html" class="sidebar-link">6.11 slot（下）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 内置组件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter7/7-1.html" class="sidebar-link">7.1 keep-alive（上）</a></li><li><a href="/./main/chapter7/7-2.html" class="sidebar-link">7.2 keep-alive（下）</a></li><li><a href="/./main/chapter7/7-3.html" class="sidebar-link">7.3 transition（上）</a></li><li><a href="/./main/chapter7/7-4.html" class="sidebar-link">7.4 transition（中）</a></li><li><a href="/./main/chapter7/7-5.html" class="sidebar-link">7.5 transition（下）</a></li><li><a href="/./main/chapter7/7-6.html" class="sidebar-link">7.6 transition-group</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第八章 Vue-router</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter8/8-1.html" class="sidebar-link">8.1 vue-router的注册</a></li><li><a href="/./main/chapter8/8-2.html" class="sidebar-link">8.2 VueRouter实例化</a></li><li><a href="/./main/chapter8/8-3.html" class="sidebar-link">8.3 动态路由</a></li><li><a href="/./main/chapter8/8-4.html" class="sidebar-link">8.4 match</a></li><li><a href="/./main/chapter8/8-5.html" class="sidebar-link">8.5 导航守卫（上）</a></li><li><a href="/./main/chapter8/8-6.html" class="sidebar-link">8.6 导航守卫（中）</a></li><li><a href="/./main/chapter8/8-7.html" class="sidebar-link">8.7 导航守卫（下）</a></li><li><a href="/./main/chapter8/8-8.html" class="sidebar-link">8.8 路径切换</a></li><li><a href="/./main/chapter8/8-9.html" class="sidebar-link">8.9 router-view组件</a></li><li><a href="/./main/chapter8/8-10.html" class="sidebar-link">8.10 router-link组件</a></li><li><a href="/./main/chapter8/8-11.html" class="sidebar-link">8.11 history模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_4-6-检测变化的坑"><a href="#_4-6-检测变化的坑" class="header-anchor">#</a> 4.6 检测变化的坑</h1> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">''</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">100</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">1000</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>  先来看个小例子，这里用<code>render</code>函数渲染了<code>this.b</code>到页面上，<code>this.b</code>在<code>create</code>中被赋值为<code>100</code>，在<code>mounted</code>中被赋值为<code>1000</code>。那么最后渲染到页面的结果是什么呢？这里问题不仅是考验对响应式的理解，还考验了对生命周期的理解。<br>
  这就引出了我们检测变化时需要注意的第一个问题，对于对象来说，<code>Vue</code>无法检测<code>property</code>的添加和删除，我们知道<code>data</code>中数据都是响应式的，但是现在我们<code>data</code>中只有<code>a</code>属性，而<code>b</code>属性则是手动添加的，由于<code>Object.defineProperty</code>特性，我们只有事先定义了对象的属性才能实现<code>get</code>拦截，也就是说我们这里只定义了<code>a</code>属性，最后只能做到拦截<code>a</code>的访问和修改，而在<code>created</code>钩子中定义<code>b</code>的时候<code>data</code>已经初始化完毕了，<code>b</code>这时候不是响应式的。但是<code>render</code>函数执行是在<code>created</code>钩子之后的，所以<code>render</code>函数中访问<code>this.b</code>时<code>b</code>已经被定义为<code>100</code>了，然后<code>100</code>就被渲染到页面上了，渲染完成后执行<code>mounted</code>钩子又修改了<code>b</code>的值，但是因为<code>b</code>不是响应式的，所以没有订阅<code>b</code>的变化，<code>b</code>的改变不能触发页面更新，尽管此时<code>b</code>的值为<code>1000</code>，但是页面仍显示<code>100</code>。
稍微修改一下上面例子就会变的十分有趣</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">''</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">100</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">1000</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1000</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>  这个时候应该显示什么结果呢？是<code>1001000</code>吗？这就是有意思的地方，对<code>b</code>的分析我们还是同上面保持一致，但是在<code>mounted</code>钩子中我们修改了<code>a</code>的值，<code>a</code>是一个响应式的，所以它会派发更新，更新时发现<code>this.b</code>的值已经是<code>1000</code>了，那就顺带把<code>b</code>也给更新了，所以此时页面显示结果是<code>10001000</code>。<br>
  这两个例子是我们用来引出问题的，现在我们来看<code>Vue</code>如何处理添加和删除时不响应的问题。<code>Vue</code>中通过一个<code>set</code>方法来实现添加时的响应。<code>Vue</code>有个全局<code>api</code>为<code>Vue.set</code>方法，它能为对象添加，还有一种写法是<code>vm.$set</code>方法。具体使用方法我们官网已经讲得很明白了，我们这里就不去讲它的用法了。<br>
  在<code>global-api/index.js</code>中<code>Vue.set</code>设置为<code>set</code>，<code>Vue.delete</code>设置为<code>del</code></p> <div class="language-js extra-class"><pre class="language-js"><code> Vue<span class="token punctuation">.</span>set <span class="token operator">=</span> <span class="token keyword">set</span>
 Vue<span class="token punctuation">.</span>delete <span class="token operator">=</span> del
</code></pre></div><p>  在<code>state.js</code>中<code>stateMixin</code>则是为<code>vm</code>实例添加了<code>$set</code>和<code>$delete</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$set <span class="token operator">=</span> <span class="token keyword">set</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$<span class="token keyword">delete</span> <span class="token operator">=</span> del
</code></pre></div><p>  这里的两种方法都指向同一个<code>set</code>和<code>del</code>方法，它们被定义于<code>observer/index.js</code>中，我们先来看看<code>set</code>方法的定义：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">target</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token literal-property property">val</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Cannot set reactive property on undefined, null, or primitive value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> target<span class="token punctuation">.</span>__ob__
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>_isVue <span class="token operator">||</span> <span class="token punctuation">(</span>ob <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">.</span>vmCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> <span class="token operator">+</span>
      <span class="token string">'at runtime - declare it upfront in the data option.'</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre></div><p>  set方法接收了三个参数，首先第一个参数是<code>target</code>，可以是一个数组或者一个对象，也就是要添加响应式属性的目标对象。然后分别是属性<code>key</code>，属性值<code>val</code>。<br>
  首先在开发时对<code>target</code>做校验，如果<code>target</code>是一个基础类型、<code>null</code>或者<code>undefined</code>时报一个警告。接下来再判断<code>target</code>是不是一个数组，如果是一个数组的话还要校验传入<code>key</code>的合法性，也就是说<code>key</code>必须是数组的索引，<code>isValidArrayIndex</code>方法可查看util文档。满足这两个条件就把<code>target.length</code>设置为<code>target.length</code>和<code>key</code>中较大的那个数，然后给数组<code>target</code>的<code>key</code>位置插入<code>val</code>，最后返回<code>val</code>。如果不满足数组的判断的话就再判断<code>target</code>上有<code>key</code>并且<code>key</code>不在<code>Object</code>的原型对象上，满足这个条件就直接使<code>target[key] = val</code>，然后返回<code>val</code>就好了。
  接下来获取<code>target.__ob__</code>属性保存在<code>ob</code>中，然后如果<code>target._isVue</code>存在或者<code>ob.vmCount</code>存在，并且是在开发环境的话就报一个警告说，不要给<code>Vue</code>实例或者根<code>$data</code>上添加响应式属性，应该在<code>data</code>中预先声明它们。如果是根<code>$data话ob.vmCount</code>是大于0的。<br>
  如果<code>ob</code>不存在则说明<code>target</code>也不是个响应式对象，那就使<code>target[key] = val</code>，然后返回<code>val</code>。
  如果代码运行到这里还没有<code>return</code>的话，那么就是一个正常的可以添加响应式的属性，那就调用<code>defineReactive</code>方法将它变为一个响应式对象，然后还要调用o<code>b.dep.notify()</code>触发一次更新，最后<code>return val</code>。<br>
  我们在4.2小节提到依赖收集过程中是有两种<code>dep'筐'</code>，当时为我们没有太过深入分析，在这里我们将会揭晓答案，一种筐是在<code>defineReactive</code>函数中定义通过<code>dep.depend</code>来调用收集依赖的筐，这种筐是用来检测传统意义上的变化，对于基础类型的数据它被修改是可以监听到的，对于引用类型数据它整体被替换也就是修改引用地址也是可以检测到的，但是对于特殊的修改方式比如对象添加属性和删除属性是无法检测的。对此Vue只能重新设计一种筐来检测这种变化。在<code>defineReactive</code>函数中如果这个响应式对象的属性仍然是一个对象的话，这时候会做一个深度响应式并且返回一个<code>childOb</code>，<code>childOb</code>是调用<code>observe</code>并通过<code>new Observer</code>返回的，在这个过程中返回了第二个筐，然后在<code>get</code>函数中会调用<code>childOb.dep.depend()</code>收集依赖，如下所示</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> getter <span class="token operator">?</span> <span class="token function">getter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">:</span> val
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>childOb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      childOb<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">dependArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> value
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>  所以之前我们一直没有去讲<code>childOb</code>的作用，因为它是为<code>Vue.set</code>定制化的一套逻辑，换句话说这里收集依赖就是为了给<code>Vue.set</code>使用，收集依赖后一切就简单了，我们只要在添加属性时候执行一次更新就好了，而后续的修改我们就不需要考虑那么多了，因为它已经是一个响应式数据了，当然这里收集依赖也是非常巧妙的，我们在执行<code>Vue.set</code>方法时候并没有触发依赖收集，也就是并没有去访问<code>get</code>函数，所以<code>childOb.dep</code>是个什么东西呢？我们不妨来看<code>set</code>函数最后是怎么执行更新的。在<code>set</code>函数最后调用<code>ob.dep.notify</code>方法，其实就是触发一次更新，我们写一个小例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>msg<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>  首先<code>msg</code>是一个响应式数据，在数据初始化过程中它会被定义为响应式数据，这样它其实会变成下面这样</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token punctuation">{</span> 
    <span class="token literal-property property">__ob__</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">value</span><span class="token operator">:</span> msg<span class="token punctuation">,</span>
      <span class="token literal-property property">dep</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token literal-property property">vmCount</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>  data.msg.__ob__其实就是我们调用<code>set</code>方法时的<code>ob</code>对象，这里我们为<code>msg</code>添加了<code>a</code>属性，然后它就去触发<code>msg</code>的依赖，这可能不是很好理解，但是也在情理之中。我们认为的依赖收集可能是改变了谁就去触发了谁的更新，但是这里我们改变了<code>a</code>却去触发<code>msg</code>的订阅者去更新，就像是子触发了改变却去触发父级的依赖更新，这是难以理解的，我们之前派发更新都是谁改变去触发谁的订阅者更新。<br>
  对于这个问题我们不妨换个角度去分析，<code>Vue.set</code>方法实际上是为<code>msg</code>添加了新属性而不是旧有属性的改变，我们说对象是对一种事物的描述，我们为一个对象添加了新的属性，也就是为事物添加了新的描述，是不是我们也在修改这个对象呢？我们为<code>msg</code>添加新属性是不是也可以理解为我们修改了<code>msg</code>对象呢？只不过这种修改不是替换整个<code>msg</code>，而是另一种修改方式。两种方式都可以理解为是对<code>msg</code>的改变，所以我们通过<code>msg</code>去触发更新也是能够理解的。这其实就是<code>Vue.set</code>定义响应式数据和在<code>data</code>中定义响应式数据本质上的不同。这种区别只体现在<code>Vue.set</code>方法中，在调用<code>Vue.set</code>方法之后，<code>msg.a</code>属性和其他响应式数据也不会有什么不同，它会有属于自己的依赖收集机制，更新后也只会触发自己的订阅者更新了。<br>
  这里我们专门指出<code>Vue.set</code>调用的是父级订阅者的更新，其实也是为了很好的解释我们为什么不能在<code>Vue</code>实例和根<code>data</code>上添加响应式属性，可能对于<code>Vue</code>实例有不同理解，因为随意为<code>Vue</code>添加属性并不是什么好事，它可能覆盖一些<code>Vue</code>的原有方法，我们在编写代码过程中也不会为<code>Vue</code>实例添加一些属性，我们对<code>this</code>的访问和修改其实最后都被代理到了<code>data</code>上，或者其他配置项上，我们添加一些公有属性也是往<code>Vue</code>的<code>prototype</code>上添加。所以原则上来说我们都不应该直接修改<code>Vue</code>的自有属性。下面我们来说根<code>data</code>为什么不能通过<code>Vue.set</code>添加属性，不知道你有没有发现<code>Vue.set</code>添加属性的前提是<code>target</code>是一个响应式数据，为什么必须要是响应式数据呢？因为如果<code>target</code>如果不是响应式数据的话，它是不会收集到依赖的，收集不到依赖的话<code>childOb.dep.depend()</code>就没有了意义，调用<code>Vue.set</code>不能手动触发更新的话那<code>Vue.set</code>方法就有了缺陷，也就失去了它的意义，之所以说这个问题是因为我们根<code>data</code>本来就不是一个响应式的对象，尽管它有<code>__ob__</code>属性但是它没有通过<code>defineReactive</code>方法拦截，在这里是一定要注意的，只有经过<code>defineRective</code>方法处理的对象才是一个响应式对象。所以在<code>Vue.set</code>方法中不允许使用根<code>data</code>作为<code>target</code>，想要为根<code>data</code>添加响应式属性必须提前在<code>data</code>中定义。<br>
  解决完添加对象属性不响应问题后后我们还需要解决删除属性的问题，<code>Vue.del</code>方法和<code>Vue.set</code>方法很类似，我们接下来分析将会变的非常容易，我们先来看源码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">target</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Cannot delete reactive property on undefined, null, or primitive value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>_isVue <span class="token operator">||</span> <span class="token punctuation">(</span>ob <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">.</span>vmCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Avoid deleting properties on a Vue instance or its root $data '</span> <span class="token operator">+</span>
      <span class="token string">'- just set it to null.'</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  同<code>Vue.set</code>类似，首先也是在开发环境判断<code>target</code>是<code>undefined</code>或者基础类型数据的话就报一个警告。<br>
  如果<code>target</code>是个数组并且<code>key</code>是数组的合法索引，还是执行<code>target.splice(key, 1)</code>方法后<code>return</code>。<br>
  接下来还是一样的逻辑获取到<code>ob</code>对象，如果<code>target</code>是<code>Vue</code>实例或者根<code>data</code>还是报一个警告并<code>return</code>。<br>
  再往下逻辑稍有不同，如果<code>key</code>不是<code>target</code>的自有属性，那就什么都不做返回，因为肯定不能去删除原型上的属性。<br>
  如果没有被前面拦截，那就正常执行<code>delete target[key]</code>，如果没有<code>ob</code>就直接<code>return</code>，否则执行<code>ob.dep.notify()</code>进行一次更新。<br>
  到这里我们对于对象的响应式特殊处理就分析完了，其实我们一直没有分析过数组的响应式实现，数组响应式实现起来比对象难的多，因为数组有很多特别的<code>api</code>会改变自身。官网清楚的指出数组不能检测以下变动：</p> <ol><li>当你利用索引直接设置一个数组项时：<code>items[1] = 1</code>。</li> <li>当你修改数组的长度时：<code>items.length = 0</code>。<br>
  为了解决第一类问题，<code>Vue</code>提供了两种解决方案。</li> <li>一种是Vue.set(items, '1', 1)。</li> <li>另一种是items.splice(items, '1', 1)。<br>
  解决第二类问题，你同样可以使用<code>splice</code>来解决</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><p>  通过上述内容，我们获取到了一些信息，数组通过索引直接修改时是检测不到变化的，这时候我们同样可以通过<code>Vue.set</code>方法来解决问题，数组是可以检测到<code>splice</code>方法带来的变化的，实际上<code>Vue.set</code>方法内部也是用了数组<code>splice</code>方法来修改数组的。<br>
  这里有个比较关键性的问题，就是为什么调用数组<code>splice</code>会触发更新？这个是我们之前没有讲到的。在4.1小节中我们分析响应式对象的实现时在<code>Observer</code>类中有这样一段逻辑我们没有去分析</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hasProto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">protoAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">copyAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这部分逻辑是关于数组响应式处理的逻辑，如果我们传入<code>value</code>被判断是一个数组时，就执行<code>if</code>内部逻辑，它内部又有两个分支，如果<code>hasProto</code>存在的话执行<code>protoAugment</code>方法，否则执行<code>copyAlugment</code>方法，首先我们看<code>hasProto</code>是个什么东西：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> hasProto <span class="token operator">=</span> <span class="token string">'__proto__'</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>  它定义于<code>util/env.js</code>中，其实就是判断我们可不可以访问对象的<code>__proto__</code>属性。然后我们来看<code>protoAugment</code>方法的定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">protoAugment</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> <span class="token literal-property property">src</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* eslint-disable no-proto */</span>
  target<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> src
  <span class="token comment">/* eslint-enable no-proto */</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  这个定义十分简单就是重写了<code>target</code>的<code>__proto__</code>，这里的重头戏在于我们传入的第二个参数<code>src</code>，也就是我们传入的<code>arrayMethods</code>方法，下面我们来看<code>arrayMethods</code>方法的定义：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>
</code></pre></div><p>  可以看到这里先是通过<code>arrayProto</code>保存数组的原型对象，然后通过<code>Object.create</code>方法创建一个继承自<code>arrayProto</code>对象保存在<code>arrayMethods</code>中，这样<code>arrayMethods</code>就是一个拥有所有数组方法的对象。然后再看下面的一大段逻辑</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// cache original method</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>  其实就是重写了数组的<code>push、pop、shift、unshift、splice、sort、reverse</code>方法，仔细看这些方法都是会改变数组本身的。<br>
  我们来看它是怎么重写这些方法的，其实重写的方式也是比较简单，先用<code>original</code>保存原有的这些方法，然后就是调用<code>def</code>方法，<code>def</code>方法我们之前分析过，它被收录到util文档。实际上就是通过<code>Object.defineProperty</code>方法为对象属性添加一个数据属性。<code>def</code>第一个参数是<code>Object</code>，第二个为<code>key</code>，第三个是<code>val</code>，这里我们<code>val</code>传入的是一个函数<code>mutator</code>，<code>val</code>是作为数据属性的<code>value</code>传入的，这里<code>mutator</code>先是执行原生的方法得到返回结果<code>result</code>，然后就获取<code>this.__ob__</code>保存在<code>ob</code>中。<br>
  接下来又定义了<code>inserted</code>变量来处理接收的参数，因为我们调用数组的这些<code>api</code>会传入参数，这里通过<code>switch</code>方法对p<code>ush、unshift、splice</code>做了特殊处理，当调用<code>push</code>或<code>unshift</code>方法时<code>inserted</code>就等于参数列表<code>args</code>，当调用<code>splice</code>方法则是从第<code>args</code>数组三位截取到最后。
  最后判断<code>inserted</code>存在的话就执行<code>ob.observeArray(inserted)</code>，我们来回顾一下这个方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">observeArray</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">items</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  其实就是为数组中元素重新做响应式。为什么是这三种方法其实也很好理解，因为这三种方法可能会添加新元素，就需要做响应式，对于其他一些排序<code>api</code>和一些删除元素的<code>api</code>就没必要去添加响应式处理了，还有一些数组<code>api</code>会返回新数组我们压根就不会去拦截它们。而且做响应式的时候也是只为新添加的元素做响应式，所以我们才定义<code>inserted</code>方法来处理参数，因为<code>push</code>和<code>unshift</code>方法的参数都是新增元素，所以我们才会直接用<code>args</code>作为<code>inserted</code>，而<code>splice</code>方法就不同了，它只有是第三个参数开始才是新增元素，所以做了单独处理。<br>
  最后处理完数组后还要做更新处理，所以调用<code>ob.dep.notify</code>方法去派发更新，最后返回<code>result</code>。
  然后我们来分析不能访问对象的<code>__proto__</code>属性时做法，也就是调用<code>copyAugment</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">copyAugment</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">target</span><span class="token operator">:</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">src</span><span class="token operator">:</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">keys</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token function">def</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  我们看它传入的参数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">copyAugment</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> arrayMethods<span class="token punctuation">,</span> arrayKeys<span class="token punctuation">)</span>
<span class="token keyword">const</span> arrayKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">)</span>
</code></pre></div><p>  这个方法看起来也很简单，就是给数组增加了这些<code>api</code>，这样在调用时会访问数组的自有方法而不是原型上的方法。
  执行完<code>copyAugment</code>方法后还有最后一段逻辑，也就是执行<code>this.observeArray</code>方法将整个数组添加为响应式的。到这里我们就将数组的响应式原理讲解完了，这也就解决我们上面问题——为什么调用数组<code>splice</code>方法会触发更新，是因为这里我们重写了它们，导致调用这些方法时候会派发更新。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./main/chapter4/4-5.html" class="prev">
        4.5 nextTick
      </a></span> <span class="next"><a href="/./main/chapter4/4-7.html">
        4.7 计算属性
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.cb86b5c8.js" defer></script><script src="./assets/js/2.8a65079d.js" defer></script><script src="./assets/js/41.1b14daa9.js" defer></script>
  </body>
</html>
