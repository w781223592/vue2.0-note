<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>卷心菜笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./logo.jpg">
    <meta name="description" content="基于vue@2.6.14的学习笔记">
    
    <link rel="preload" href="./assets/css/0.styles.74c59701.css" as="style"><link rel="preload" href="./assets/js/app.20317d9d.js" as="script"><link rel="preload" href="./assets/js/2.8a65079d.js" as="script"><link rel="preload" href="./assets/js/10.3d2f32ec.js" as="script"><link rel="prefetch" href="./assets/js/11.132a26b4.js"><link rel="prefetch" href="./assets/js/12.d0193009.js"><link rel="prefetch" href="./assets/js/13.07872830.js"><link rel="prefetch" href="./assets/js/14.96a92186.js"><link rel="prefetch" href="./assets/js/15.89c1bf18.js"><link rel="prefetch" href="./assets/js/16.78f7cadf.js"><link rel="prefetch" href="./assets/js/17.eee5b860.js"><link rel="prefetch" href="./assets/js/18.e94d03e8.js"><link rel="prefetch" href="./assets/js/19.9e73c1ac.js"><link rel="prefetch" href="./assets/js/20.ae18bc8e.js"><link rel="prefetch" href="./assets/js/21.d4a5ba0b.js"><link rel="prefetch" href="./assets/js/22.e7794d4a.js"><link rel="prefetch" href="./assets/js/23.adaee962.js"><link rel="prefetch" href="./assets/js/24.e1df98bf.js"><link rel="prefetch" href="./assets/js/25.c325e810.js"><link rel="prefetch" href="./assets/js/26.c24daaf7.js"><link rel="prefetch" href="./assets/js/27.a3f09949.js"><link rel="prefetch" href="./assets/js/28.123d6383.js"><link rel="prefetch" href="./assets/js/29.04a6e255.js"><link rel="prefetch" href="./assets/js/3.5a34bef2.js"><link rel="prefetch" href="./assets/js/30.f976c0a7.js"><link rel="prefetch" href="./assets/js/31.60d2f4c4.js"><link rel="prefetch" href="./assets/js/32.6b2a5515.js"><link rel="prefetch" href="./assets/js/33.6b80e89d.js"><link rel="prefetch" href="./assets/js/34.ea39628f.js"><link rel="prefetch" href="./assets/js/35.4c14bc3d.js"><link rel="prefetch" href="./assets/js/36.5f2b7559.js"><link rel="prefetch" href="./assets/js/37.57e976da.js"><link rel="prefetch" href="./assets/js/38.191568b8.js"><link rel="prefetch" href="./assets/js/39.f89500e6.js"><link rel="prefetch" href="./assets/js/4.9fb18247.js"><link rel="prefetch" href="./assets/js/40.a45a4a21.js"><link rel="prefetch" href="./assets/js/41.94ece143.js"><link rel="prefetch" href="./assets/js/42.224304d2.js"><link rel="prefetch" href="./assets/js/43.544241cd.js"><link rel="prefetch" href="./assets/js/44.6014c885.js"><link rel="prefetch" href="./assets/js/45.711ad2c3.js"><link rel="prefetch" href="./assets/js/46.19b76064.js"><link rel="prefetch" href="./assets/js/47.0a8f7a4f.js"><link rel="prefetch" href="./assets/js/48.da28ae74.js"><link rel="prefetch" href="./assets/js/49.97615384.js"><link rel="prefetch" href="./assets/js/5.0c239c66.js"><link rel="prefetch" href="./assets/js/50.06bd69e2.js"><link rel="prefetch" href="./assets/js/51.ea943f69.js"><link rel="prefetch" href="./assets/js/52.b4813218.js"><link rel="prefetch" href="./assets/js/53.c1ba1696.js"><link rel="prefetch" href="./assets/js/54.e1d1801c.js"><link rel="prefetch" href="./assets/js/55.ac7cd0ab.js"><link rel="prefetch" href="./assets/js/56.d55c7dcb.js"><link rel="prefetch" href="./assets/js/57.83bbfc8e.js"><link rel="prefetch" href="./assets/js/58.6996ec46.js"><link rel="prefetch" href="./assets/js/59.42c770e8.js"><link rel="prefetch" href="./assets/js/6.0600552c.js"><link rel="prefetch" href="./assets/js/60.919088d2.js"><link rel="prefetch" href="./assets/js/61.455d2404.js"><link rel="prefetch" href="./assets/js/62.40ba97a6.js"><link rel="prefetch" href="./assets/js/63.5b069dba.js"><link rel="prefetch" href="./assets/js/64.512e158a.js"><link rel="prefetch" href="./assets/js/65.6ca1c75b.js"><link rel="prefetch" href="./assets/js/66.0356130d.js"><link rel="prefetch" href="./assets/js/67.93a0d7df.js"><link rel="prefetch" href="./assets/js/68.7e44cc19.js"><link rel="prefetch" href="./assets/js/69.788a4d27.js"><link rel="prefetch" href="./assets/js/7.6346a45d.js"><link rel="prefetch" href="./assets/js/70.571f8a79.js"><link rel="prefetch" href="./assets/js/71.f54eb805.js"><link rel="prefetch" href="./assets/js/72.02cd77d0.js"><link rel="prefetch" href="./assets/js/73.66b6b1d0.js"><link rel="prefetch" href="./assets/js/74.96bf5acc.js"><link rel="prefetch" href="./assets/js/75.1b135bdd.js"><link rel="prefetch" href="./assets/js/76.6ed173f1.js"><link rel="prefetch" href="./assets/js/77.ee856c8d.js"><link rel="prefetch" href="./assets/js/78.b8fc2c30.js"><link rel="prefetch" href="./assets/js/79.7665732d.js"><link rel="prefetch" href="./assets/js/8.6ff51652.js"><link rel="prefetch" href="./assets/js/80.03e59e67.js"><link rel="prefetch" href="./assets/js/81.a6236c2f.js"><link rel="prefetch" href="./assets/js/82.88a5092b.js"><link rel="prefetch" href="./assets/js/83.e93ce178.js"><link rel="prefetch" href="./assets/js/84.8eb37a19.js"><link rel="prefetch" href="./assets/js/85.9d8d91db.js"><link rel="prefetch" href="./assets/js/86.14696351.js"><link rel="prefetch" href="./assets/js/87.51a4cddc.js"><link rel="prefetch" href="./assets/js/88.5cb86311.js"><link rel="prefetch" href="./assets/js/89.11fe5589.js"><link rel="prefetch" href="./assets/js/9.aaa202b7.js"><link rel="prefetch" href="./assets/js/90.b3555572.js">
    <link rel="stylesheet" href="./assets/css/0.styles.74c59701.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">卷心菜笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/./main/" aria-current="page" class="sidebar-link">前言</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 初识Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter1/1-1.html" class="sidebar-link">1.1 Vue目录设计</a></li><li><a href="/./main/chapter1/1-2.html" class="sidebar-link">1.2 Vue入口文件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 Vue初始化和挂载</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter2/2-1.html" class="sidebar-link">2.1 new Vue()时做了什么</a></li><li><a href="/./main/chapter2/2-2.html" class="sidebar-link">2.2 Vue实例挂载的实现</a></li><li><a href="/./main/chapter2/2-3.html" class="sidebar-link">2.3 Vue挂载时的mountComponent</a></li><li><a href="/./main/chapter2/2-4.html" class="sidebar-link">2.4 Virtual DOM</a></li><li><a href="/./main/chapter2/2-5.html" class="sidebar-link">2.5 最终的挂载方法_update</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第三章 组件化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter3/3-1.html" aria-current="page" class="active sidebar-link">3.1 创建组件vnode</a></li><li><a href="/./main/chapter3/3-2.html" class="sidebar-link">3.2 组件的patch过程</a></li><li><a href="/./main/chapter3/3-3.html" class="sidebar-link">3.3 合并配置</a></li><li><a href="/./main/chapter3/3-4.html" class="sidebar-link">3.4 生命周期（上）</a></li><li><a href="/./main/chapter3/3-5.html" class="sidebar-link">3.5 生命周期（下）</a></li><li><a href="/./main/chapter3/3-6.html" class="sidebar-link">3.6 组件的注册</a></li><li><a href="/./main/chapter3/3-7.html" class="sidebar-link">3.7 异步组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第四章 响应式原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter4/4-1.html" class="sidebar-link">4.1 响应式对象</a></li><li><a href="/./main/chapter4/4-2.html" class="sidebar-link">4.2 依赖收集（上）</a></li><li><a href="/./main/chapter4/4-3.html" class="sidebar-link">4.3 依赖收集（下）</a></li><li><a href="/./main/chapter4/4-4.html" class="sidebar-link">4.4 派发更新</a></li><li><a href="/./main/chapter4/4-5.html" class="sidebar-link">4.5 nextTick</a></li><li><a href="/./main/chapter4/4-6.html" class="sidebar-link">4.6 检测变化的坑</a></li><li><a href="/./main/chapter4/4-7.html" class="sidebar-link">4.7 计算属性</a></li><li><a href="/./main/chapter4/4-8.html" class="sidebar-link">4.8 侦听器</a></li><li><a href="/./main/chapter4/4-9.html" class="sidebar-link">4.9 组件更新</a></li><li><a href="/./main/chapter4/4-10.html" class="sidebar-link">4.10 diff算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter5/5-1.html" class="sidebar-link">5.1 初探编译器</a></li><li><a href="/./main/chapter5/5-2.html" class="sidebar-link">5.2 从入口开始</a></li><li><a href="/./main/chapter5/5-3.html" class="sidebar-link">5.3 parse之解析模板（上）</a></li><li><a href="/./main/chapter5/5-4.html" class="sidebar-link">5.4 parse之解析模板（下）</a></li><li><a href="/./main/chapter5/5-5.html" class="sidebar-link">5.5 parse之生成AST（1）</a></li><li><a href="/./main/chapter5/5-6.html" class="sidebar-link">5.6 parse之生成AST（2）</a></li><li><a href="/./main/chapter5/5-7.html" class="sidebar-link">5.7 parse之生成AST（3）</a></li><li><a href="/./main/chapter5/5-8.html" class="sidebar-link">5.8 parse之生成AST（4）</a></li><li><a href="/./main/chapter5/5-9.html" class="sidebar-link">5.9 parse之生成AST（5）</a></li><li><a href="/./main/chapter5/5-10.html" class="sidebar-link">5.10 optimize优化</a></li><li><a href="/./main/chapter5/5-11.html" class="sidebar-link">5.11 generate代码生成（1）</a></li><li><a href="/./main/chapter5/5-12.html" class="sidebar-link">5.12 generate代码生成（2）</a></li><li><a href="/./main/chapter5/5-13.html" class="sidebar-link">5.13 generate代码生成（3）</a></li><li><a href="/./main/chapter5/5-14.html" class="sidebar-link">5.14 generate代码生成（4）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter6/6-1.html" class="sidebar-link">6.1 events（1）</a></li><li><a href="/./main/chapter6/6-2.html" class="sidebar-link">6.2 events（2）</a></li><li><a href="/./main/chapter6/6-3.html" class="sidebar-link">6.3 events（3）</a></li><li><a href="/./main/chapter6/6-4.html" class="sidebar-link">6.4 events（4）</a></li><li><a href="/./main/chapter6/6-5.html" class="sidebar-link">6.5 v-model（1）</a></li><li><a href="/./main/chapter6/6-6.html" class="sidebar-link">6.6 v-model（2）</a></li><li><a href="/./main/chapter6/6-7.html" class="sidebar-link">6.7 v-model（3）</a></li><li><a href="/./main/chapter6/6-8.html" class="sidebar-link">6.8 v-model（4）</a></li><li><a href="/./main/chapter6/6-9.html" class="sidebar-link">6.9 slot（上）</a></li><li><a href="/./main/chapter6/6-10.html" class="sidebar-link">6.10 slot（中）</a></li><li><a href="/./main/chapter6/6-11.html" class="sidebar-link">6.11 slot（下）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 内置组件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter7/7-1.html" class="sidebar-link">7.1 keep-alive（上）</a></li><li><a href="/./main/chapter7/7-2.html" class="sidebar-link">7.2 keep-alive（下）</a></li><li><a href="/./main/chapter7/7-3.html" class="sidebar-link">7.3 transition（上）</a></li><li><a href="/./main/chapter7/7-4.html" class="sidebar-link">7.4 transition（中）</a></li><li><a href="/./main/chapter7/7-5.html" class="sidebar-link">7.5 transition（下）</a></li><li><a href="/./main/chapter7/7-6.html" class="sidebar-link">7.6 transition-group</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第八章 Vue-router</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter8/8-1.html" class="sidebar-link">8.1 vue-router的注册</a></li><li><a href="/./main/chapter8/8-2.html" class="sidebar-link">8.2 VueRouter实例化</a></li><li><a href="/./main/chapter8/8-3.html" class="sidebar-link">8.3 动态路由</a></li><li><a href="/./main/chapter8/8-4.html" class="sidebar-link">8.4 match</a></li><li><a href="/./main/chapter8/8-5.html" class="sidebar-link">8.5 导航守卫（上）</a></li><li><a href="/./main/chapter8/8-6.html" class="sidebar-link">8.6 导航守卫（中）</a></li><li><a href="/./main/chapter8/8-7.html" class="sidebar-link">8.7 导航守卫（下）</a></li><li><a href="/./main/chapter8/8-8.html" class="sidebar-link">8.8 路径切换</a></li><li><a href="/./main/chapter8/8-9.html" class="sidebar-link">8.9 router-view组件</a></li><li><a href="/./main/chapter8/8-10.html" class="sidebar-link">8.10 router-link组件</a></li><li><a href="/./main/chapter8/8-11.html" class="sidebar-link">8.11 history模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>  组件化是<code>vue.js</code>的一个核心思想。组件就是将一段样式和其对应的功能作为独立的整体去看待，无论这个整体放在哪里去使用，它都具有一样的功能和样式，从而实现复用，这种整体化的思想就是组件化。组件化设计就是为了增加复用性，灵活性，提高系统设计，从而提高开发效率。</p> <h1 id="_3-1-创建组件vnode"><a href="#_3-1-创建组件vnode" class="header-anchor">#</a> 3.1 创建组件vnode</h1> <p>组件这个名词对于我们使用过<code>vue</code>的人来说不会太陌生，写代码就好像盖房子一样，通过各个部件组成摩天大楼，接下来我们来分析<code>vue</code>中的组件化实现。
在前面我们分析<code>_createElement</code>方法的时候有这样一段对<code>tag</code>类型的判断：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> tag <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// direct component options / constructor</span>
    vnode <span class="token operator">=</span> <span class="token function">createComponent</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们之前手写<code>render</code>函数的时候<code>tag</code>是一个字符串类似于<code>div</code>这种，所以我们之前只分析了<code>tag</code>类型是<code>string</code>时候的逻辑，其实<code>else</code>中是组件相关逻辑，前面已经分析过了<code>_createElement</code>方法最终就是返回<code>vnode</code>，很明显<code>else</code>中逻辑就是将组件转化成<code>vnode</code>的过程，它使<code>vnode</code>等于<code>createComponent()</code>方法返回结果。	
我们先来写这样一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><p>这个简单的<code>dome</code>就是渲染了<code>App</code>组件，我们在<code>initRender</code>文档中已经分析过<code>render</code>
函数中h方法的调用其实就是<code>_createElement</code>方法调用，我们这里只传入一个App组件实例，也就是<code>_createElement</code>方法的第二个参数<code>tag</code>（第一个参数是<code>new Vue</code>实例，在<code>_createElement</code>定义时已经被绑定），所以这里的<code>tag</code>是一个<code>object</code>而不是<code>string</code>，
所以执行的是<code>createComponent</code>逻辑
下面来分析<code>createElement()</code>方法，该方法定义在<code>vdom/create-component</code>文件下。这个函数内容还是比较多的我们还是拆解开来分析，它最终的返回值必然是<code>vnode</code>了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComponent</span> <span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">Ctor</span><span class="token operator">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span> <span class="token operator">|</span> Function <span class="token operator">|</span> Object <span class="token operator">|</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token operator">?</span>VNodeData<span class="token punctuation">,</span>
  context<span class="token operator">:</span> Component<span class="token punctuation">,</span>
  children<span class="token operator">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  tag<span class="token operator">?</span><span class="token operator">:</span> string</span>
<span class="token punctuation">)</span><span class="token operator">:</span> VNode <span class="token operator">|</span> Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> baseCtor <span class="token operator">=</span> context<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_base <span class="token comment">// init时候设置为Vue 在 global-api/index.js</span>
</code></pre></div><p>我们先来看它的参数，第一个参数是<code>Ctor</code>，可以是一个组件<code>class</code>、函数、对象、空，这里传入的是<code>tag</code>，也就是<code>import App</code>生成的对象，如下所示：</p> <div class="center"><img src="data:image/png;base64,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"></div> <p>第二个参数<code>data</code>是可选参数；第三个参数<code>context</code>也就是父级<code>vm</code>实例；第四个参数<code>children</code>也是可选，第五个参数<code>tag</code>也是可选，我们上面调用的时候传了<code>tag</code>、<code>data</code>、<code>context</code>、<code>children</code>四个参数。
然后我们看函数执行逻辑，首先是判断如果<code>Ctor</code>未定义就直接<code>return</code>，如果有的话就执行下一步。定义<code>baseCtor</code>变量为<code>context.$options._base</code>，这个属性在<code>init</code>时候被赋值为<code>Vue</code>，其逻辑在<code>global-api/init</code>文件下<code>initGlobalAPI()</code>函数中</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>options<span class="token punctuation">.</span>_base <span class="token operator">=</span> Vue
</code></pre></div><p>在初始化全局api的时候它被赋值为<code>Vue</code>，我们在开发过程中第一个操作总是去<code>new</code> <code>Vue()</code>，这时候我们执行init时候我们有合并<code>options</code>操作，这就使得我们<code>Vue</code>上的<code>options</code>被合并到了<code>vm.$options</code>上，然后我们就能在这儿获取到<code>Vue</code>，
所以我们这里<code>baseCtor</code>就是<code>Vue</code>，然后看接下来的逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// plain options object: turn it into a constructor</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isObject</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Ctor <span class="token operator">=</span> baseCtor<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>根据注释解释它是将普通对象转化为一个构造器，如果<code>Ctor</code>是一个对象类型(包括数组)，就使<code>Ctor</code>等于<code>Vue.extend(Ctor)</code>，下面我们就来看一下<code>Vue</code>全局<code>api</code>中的<code>extend</code>方法。<code>extend</code>方法的定义在<code>global-api/extend.js</code>文件下，在<code>initExtend</code>时候为<code>Vue</code>扩展了<code>extend</code>方法，该方法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>  Vue<span class="token punctuation">.</span><span class="token function-variable function">extend</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">extendOptions</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span><span class="token operator">:</span> Function <span class="token punctuation">{</span>
    extendOptions <span class="token operator">=</span> extendOptions <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">const</span> Super <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> SuperId <span class="token operator">=</span> Super<span class="token punctuation">.</span>cid
    <span class="token keyword">const</span> cachedCtors <span class="token operator">=</span> extendOptions<span class="token punctuation">.</span>_Ctor <span class="token operator">||</span> <span class="token punctuation">(</span>extendOptions<span class="token punctuation">.</span>_Ctor <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedCtors<span class="token punctuation">[</span>SuperId<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cachedCtors<span class="token punctuation">[</span>SuperId<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> name <span class="token operator">=</span> extendOptions<span class="token punctuation">.</span>name <span class="token operator">||</span> Super<span class="token punctuation">.</span>options<span class="token punctuation">.</span>name
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">validateComponentName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><code>extend</code>方法接收一个参数<code>extendOptions</code>，函数开始将空<code>extendOptions</code>赋值为<code>{}</code>，然后定义<code>Super</code>变量保存<code>Vue</code>，这里this就是指向<code>Vue</code>的，然后定义<code>SuperId</code>来保存<code>initExtend</code>方法开头定义的<code>Vue.cid = 0</code>，接着定义<code>cachedCtors</code>来做一个缓存优化，主要在<code>extendOptions</code>没有<code>_Ctor</code>属性时对其扩展一个<code>_Ctor</code>属性，若<code>_Ctor</code>已经存在就把它赋值给<code>cachedCtors</code>，缓存是在后面做的，我们一会就见到了。
接着判断<code>cachedCtors</code>中已有<code>SuperId</code>对应的缓存就直接返回缓存好的构造器。下一步定义了<code>name</code>变量等于 <code>extendOptions.name</code>或者<code>Suer.options.name</code>，在非生产环境且<code>name</code>存在的情况下执行<code>validateComponentName(name)</code>，接下来我们看看这个方法做了什么，通常在非开发环境的逻辑都是做一些校验，抛出一些错误和警告方便我们开发者定位错误，相信这儿也不例外，<code>validateComponentName定义于intance/util/options.js</code>下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">validateComponentName</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">name</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">^[a-zA-Z][\\-\\.0-9_</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>unicodeRegExp<span class="token punctuation">.</span>source<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]*$</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Invalid component name: &quot;'</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'&quot;. Component names '</span> <span class="token operator">+</span>
      <span class="token string">'should conform to valid custom element name in html5 specification.'</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// isBuiltInTag()判断是否是Vue标签， config.isReservedTag()判断是否是平台保留标签（html标签）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBuiltInTag</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isReservedTag</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Do not use built-in or reserved HTML elements as component '</span> <span class="token operator">+</span>
      <span class="token string">'id: '</span> <span class="token operator">+</span> name
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>validateComponentName</code>校验首先是对符合<code>html5</code>规范有效自定义名称的校验，如果不符合规范就报一个警告。然后判断<code>isBuiltInTag() || config.isReservedTag()</code>，<code>isReservedTag</code>是不是很眼熟，在之前<code>_createElement</code>方法中判断<code>tag</code>类型为<code>string</code>时候的逻辑中已经用过这个判断了，当时是用来校验在原生<code>html</code>标签使用<code>.native</code>事件修饰符的时候用到的，这个在<code>helper</code>文档中有收录到，再来看<code>isBuiltInTag</code>方法，它是判断是否是<code>Vue</code>保留标签的方法，同样的我们把它收录到<code>helper</code>文档中。如果我们一旦用了原生<code>html</code>标签作为组件<code>name</code>时候就会报出上面这条警告。
接着回到我们<code>extend</code>方法中：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">const</span> <span class="token function-variable function">Sub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">VueComponent</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
    <span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub
    Sub<span class="token punctuation">.</span>cid <span class="token operator">=</span> cid<span class="token operator">++</span>
    Sub<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
      Super<span class="token punctuation">.</span>options<span class="token punctuation">,</span>
      extendOptions
    <span class="token punctuation">)</span>
    Sub<span class="token punctuation">[</span><span class="token string">'super'</span><span class="token punctuation">]</span> <span class="token operator">=</span> Super
</code></pre></div><p>定义了一个子构造函数<code>Sub</code>，参数一样是<code>options</code>，一样执行了<code>this._init()</code>方法，再往下看<code>Sub.prototype</code>被赋值为一个由继承自<code>Super.prototype</code>的对象，实际上就是给<code>Sub</code>原型上挂上和<code>Vue</code>原型一样方法或属性，让它有和<code>Vue</code>一样的能力，给<code>Sub.prototype.constructor</code>赋值为<code>Sub</code>，然后给<code>Sub</code>设置唯一标识<code>cid</code>，再给<code>Sub</code>赋值合并后的<code>options</code>，合并时调用<code>mergeOptions()</code>方法，该方法被多次调用，我们之后会专门分析它。然后设置<code>Sub</code>的<code>super</code>属性为<code>Super</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// For props and computed properties, we define the proxy getters on</span>
  <span class="token comment">// the Vue instances at extension time, on the extended prototype. This</span>
  <span class="token comment">// avoids Object.defineProperty calls for each instance created.</span>
	<span class="token comment">// 对于props和computed属性，我们在扩展时在扩展原型的Vue实例上定义代理	getter。这避免了Object.defineProperty为创建的每个实例调用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>options<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">initProps</span><span class="token punctuation">(</span>Sub<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Sub<span class="token punctuation">.</span>options<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">initComputed</span><span class="token punctuation">(</span>Sub<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>接着判断<code>Sub.options</code>方法上是否存在<code>props</code>和<code>computed</code>，如果存在就分别进行初始化。我们先看<code>initProps</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">initProps</span> <span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> props <span class="token operator">=</span> Comp<span class="token punctuation">.</span>options<span class="token punctuation">.</span>props
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token class-name">Comp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_props</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>先获取到<code>props</code>对象，然通过<code>for ... in</code> 遍历执行<code>proxy()</code>方法，<code>proxy</code>方法定义在<code>instance/state.js</code>文件下，其实我们之前分析<code>initState</code>时候已经分析过它，其作用就是通过<code>Object.defineProperty</code>做数据劫持，<code>proxy()</code>详解。然后是<code>initComputed</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">initComputed</span> <span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> computed <span class="token operator">=</span> Comp<span class="token punctuation">.</span>options<span class="token punctuation">.</span>computed
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> computed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">defineComputed</span><span class="token punctuation">(</span><span class="token class-name">Comp</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> key<span class="token punctuation">,</span> computed<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>换药不换汤，只是遍历执行的方法改为了<code>defineComputed()</code>，我们把这部分分析也写在<a href="/./appendix/initState.html">initState文档</a>中，因为它也是在<code>state.js</code>文件下定义的。它传入了三个参数，第一个也就是<code>Sub</code>的原型对象，第二个是遍历到的<code>key</code>，第三个则是<code>key</code>对应的<code>value</code>值。最后同样是做了数据的劫持。
所以组件初始化<code>props</code>和<code>computed</code>时机是在定义子类构造函数的时候，官方注释说是为了避免<code>Object.defineProperty</code>方法在每次实例化组件时候都被调用。</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// allow further extension/mixin/plugin usage</span>
    Sub<span class="token punctuation">.</span>extend <span class="token operator">=</span> Super<span class="token punctuation">.</span>extend
    Sub<span class="token punctuation">.</span>mixin <span class="token operator">=</span> Super<span class="token punctuation">.</span>mixin
    Sub<span class="token punctuation">.</span>use <span class="token operator">=</span> Super<span class="token punctuation">.</span>use
</code></pre></div><p>然后添<code>extend</code>、<code>mixin</code>、<code>use</code>属性，就是<code>Vue</code>有的东西它都要有。</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// create asset registers, so extended classes</span>
    <span class="token comment">// can have their private assets too.</span>
    <span class="token constant">ASSET_TYPES</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Sub<span class="token punctuation">[</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> Super<span class="token punctuation">[</span>type<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// enable recursive self-lookup 启用递归自查</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Sub<span class="token punctuation">.</span>options<span class="token punctuation">.</span>components<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> Sub
    <span class="token punctuation">}</span>
</code></pre></div><p>然后添加<code>ASSET_TYPES</code>里面的属性，包括<code>component</code>、<code>directive</code>、<code>filter</code>属性，然后在<code>name</code>存在时候启用递归自查</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// keep a reference to the super options at extension time.</span>
    <span class="token comment">// later at instantiation we can check if Super's options have</span>
    <span class="token comment">// been updated.</span>
    <span class="token comment">//扩展时保留super options的引用，稍后在实例化时，</span>
    <span class="token comment">// 我们可以检查Super的选项是否已更新。</span>
    Sub<span class="token punctuation">.</span>superOptions <span class="token operator">=</span> Super<span class="token punctuation">.</span>options
    Sub<span class="token punctuation">.</span>extendOptions <span class="token operator">=</span> extendOptions
    Sub<span class="token punctuation">.</span>sealedOptions <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> Sub<span class="token punctuation">.</span>options<span class="token punctuation">)</span>

    <span class="token comment">// cache constructor</span>
    cachedCtors<span class="token punctuation">[</span>SuperId<span class="token punctuation">]</span> <span class="token operator">=</span> Sub
    <span class="token keyword">return</span> Sub
  <span class="token punctuation">}</span>
</code></pre></div><p>最后缓存<code>Sub</code>，开头对<code>cachedCtor[SuperId]</code>的<code>if</code>判断就是判断之前有没有缓存过这个<code>Sub</code>，我们每次引入同一个组件时引入的是同一个对象，这意味着<code>extendOptions</code>是相同的，所以我们可以找到之前的<code>extendOptions._Ctor</code>，然后我们就可以取到上次缓存的构造器了。但是这样来看<code>SuperId</code>是不是就没有意义了呢？之前我们分析过了<code>Super</code>其实就是<code>Vue</code>，<code>Vue.cid</code>是等于<code>0</code>的，我们没有在任何地方去修改它的值。而取这个缓存我们也是在组件对象中取的，那这个<code>SuperId</code>的意义在哪呢？它标识的是父构造器，0就是Vue构造器标识，我们之前也给<code>Sub</code>赋值了<code>extend</code>方法，所以<code>Sub</code>是可以继续构造新的子类，我们构造的每一个<code>Sub</code>都有唯一的cid标识，如果调用<code>Sub.extend</code>时我们将获得新的子类，这时候<code>SuperId</code>就是<code>Sub</code>的<code>cid</code>了，所以<code>SuperId</code>标识的这个子类是由哪个父构造器创建的。然后再考虑个问题，既然这里<code>cachedCtor</code>被定义为一个对象，说明它不会只有一个缓存，那么什么时候它会有多个构造器缓存呢？那就是当一个组件通过不同的父构造器构建子类构造器时那它就会缓存多个<code>Ctor</code>了。我们分析这儿就可以，至于实际有没有这样的运用就只能实践出真知了。最后<code>extend</code> 方法返回了<code>Sub</code>构造器。
回到<code>createComponent</code>方法中，我们一句话来解释<code>extend</code>就是通过继承方式创建了一个子构造器，<code>Ctor</code>就是这个构造器。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// if at this stage it's not a constructor or an async component factory,</span>
  <span class="token comment">// reject.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Ctor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Invalid Component definition: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">String</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>如果<code>Ctor</code>不是一个函数就报一个无效的组件定义警告。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// async component</span>
  <span class="token keyword">let</span> asyncFactory
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>cid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    asyncFactory <span class="token operator">=</span> Ctor
    Ctor <span class="token operator">=</span> <span class="token function">resolveAsyncComponent</span><span class="token punctuation">(</span>asyncFactory<span class="token punctuation">,</span> baseCtor<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Ctor <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// return a placeholder node for async component, which is rendered</span>
      <span class="token comment">// as a comment node but preserves all the raw information for the node.</span>
      <span class="token comment">// the information will be used for async server-rendering and hydration.</span>
      <span class="token keyword">return</span> <span class="token function">createAsyncPlaceholder</span><span class="token punctuation">(</span>
        asyncFactory<span class="token punctuation">,</span>
        data<span class="token punctuation">,</span>
        context<span class="token punctuation">,</span>
        children<span class="token punctuation">,</span>
        tag
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>这部分是对异步组件的处理，我们在后面小节中会专门分析异步组件。</p> <div class="language-js extra-class"><pre class="language-js"><code>  data <span class="token operator">=</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>对data进行简单的处理</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// resolve constructor options in case global mixins are applied after</span>
  <span class="token comment">// component constructor creation</span>
  <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span>
</code></pre></div><p>对<code>options</code>重新计算，因为可能被一些全局的<code>mixins</code>所影响，接下来我们来看看<code>resolveConstructorOptions</code>方法的定义：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">resolveConstructorOptions</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">Ctor</span><span class="token operator">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> options <span class="token operator">=</span> Ctor<span class="token punctuation">.</span>options
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>super<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> superOptions <span class="token operator">=</span> <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>super<span class="token punctuation">)</span>
    <span class="token keyword">const</span> cachedSuperOptions <span class="token operator">=</span> Ctor<span class="token punctuation">.</span>superOptions
    <span class="token keyword">if</span> <span class="token punctuation">(</span>superOptions <span class="token operator">!==</span> cachedSuperOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// super option changed,</span>
      <span class="token comment">// need to resolve new options.</span>
      Ctor<span class="token punctuation">.</span>superOptions <span class="token operator">=</span> superOptions
      <span class="token comment">// check if there are any late-modified/attached options (#4976)</span>
      <span class="token comment">// 检查是否有任何延迟修改/附加选项</span>
      <span class="token keyword">const</span> modifiedOptions <span class="token operator">=</span> <span class="token function">resolveModifiedOptions</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span>
      <span class="token comment">// update base extend options</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>modifiedOptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">extend</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>extendOptions<span class="token punctuation">,</span> modifiedOptions<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      options <span class="token operator">=</span> Ctor<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>superOptions<span class="token punctuation">,</span> Ctor<span class="token punctuation">.</span>extendOptions<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        options<span class="token punctuation">.</span>components<span class="token punctuation">[</span>options<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> Ctor
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> options
<span class="token punctuation">}</span>
</code></pre></div><p>该方法定义在<code>instance/init.js</code>文件下（最开始<code>_init</code>时候我们已经调用过这个方法，但是我们前面没有分析，现在我们放到这里讲解），首先从<code>Ctor</code>上获取<code>options</code>，如果<code>Ctor.options</code>存在，则传入<code>Ctor.super</code>递归调用<code>resolveConstructorOptions</code>，并使用<code>superOptions</code>保存返回的<code>options</code>，直到该构造器是最顶级父构造器为止。然后定义<code>cachedSuperOptions</code>保存<code>Ctor.superOptions</code>，之前已经提到了过了<code>Ctor</code>这个属性就是保存了<code>Vue.extend</code>时候的父构造器的<code>options</code>，它的定义就是为了这儿检查它是否被改变。正常情况<code>superOptions</code>和<code>cachedSuperOptions</code>是相等，但是因为一些全局的混入可能导致<code>super</code>的<code>options</code>被改变了，所以接下来对这种情况做了处理，先将<code>Ctor</code>的<code>superOptions</code>属性同步修改为<code>superOptions</code>。
然后定义变量<code>modifiedOptions</code>保存<code>resolveModifiedOptions(Ctor)</code>返回，所以我们接下来看看<code>resolveModifiedOptions</code>方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">resolveModifiedOptions</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">Ctor</span><span class="token operator">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>Object <span class="token punctuation">{</span>
  <span class="token keyword">let</span> modified
  <span class="token keyword">const</span> latest <span class="token operator">=</span> Ctor<span class="token punctuation">.</span>options
  <span class="token keyword">const</span> sealed <span class="token operator">=</span> Ctor<span class="token punctuation">.</span>sealedOptions
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> latest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>latest<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> sealed<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>modified<span class="token punctuation">)</span> modified <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      modified<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> latest<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> modified
<span class="token punctuation">}</span>
</code></pre></div><p>该方法定义在同文件下，首先定义<code>modified</code>来保存改变的内容，然后定义<code>latest为Ctor.options</code>,也就是自身的<code>options</code>，再定义了<code>sealed</code>为<code>Ctor.sealedOptions</code>，密封的<code>options</code>也就是调用<code>Vue.extend</code>时候保存的自身<code>options</code>，为了方便这儿自查所以密封起来。然后遍历当前<code>options</code>，对比前后是否有不同属性，将差异化属性还是由键值对方式保存到<code>modified</code>中，最后返回<code>modified</code>。
接下来我们就回到<code>resolveConstructorOptions</code>函数中的<code>if(modifiedOptions)</code>判断了，执行<code>extend(Ctor.extendOptions, modifiedOptions)</code>方法将修改的属性同步到<code>Ctor.extendOptions</code>中，然后再次合并<code>options</code>并用<code>options</code>保存合并后的<code>options</code>并将其赋值给<code>Ctor.options</code>。然后<code>options.name</code>存在的话就让<code>options.components[options.name]</code>等于<code>Ctor</code>。最后返回options。
我们回到<code>createComponent</code>方法中，它对<code>v-model</code>做了一些处理，之后分析双向绑定时候我们再来分析</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// transform component v-model data into props &amp; events</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">transformModel</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>options<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>提取<code>props</code></p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// extract props 提取props</span>
  <span class="token keyword">const</span> propsData <span class="token operator">=</span> <span class="token function">extractPropsFromVNodeData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> Ctor<span class="token punctuation">,</span> tag<span class="token punctuation">)</span>
</code></pre></div><p>函数组件</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// functional component</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>options<span class="token punctuation">.</span>functional<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createFunctionalComponent</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>这些内容我们先略过，在之后的章节详细分析。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// extract listeners, since these needs to be treated as</span>
  <span class="token comment">// child component listeners instead of DOM listeners</span>
  <span class="token comment">// 提取侦听器，因为它们需要被视为子组件侦听器而不是DOM侦听器</span>

  <span class="token keyword">const</span> listeners <span class="token operator">=</span> data<span class="token punctuation">.</span>on
  <span class="token comment">// replace with listeners with .native modifier</span>
  <span class="token comment">// so it gets processed during parent component patch.</span>
  <span class="token comment">// 替换为带有“native”修饰符的侦听器，以便在父组件patch期间对其进行处理</span>
  data<span class="token punctuation">.</span>on <span class="token operator">=</span> data<span class="token punctuation">.</span>nativeOn

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// abstract components do not keep anything</span>
    <span class="token comment">// other than props &amp; listeners &amp; slot</span>
    <span class="token comment">// work around flow</span>
    <span class="token keyword">const</span> slot <span class="token operator">=</span> data<span class="token punctuation">.</span>slot
    data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      data<span class="token punctuation">.</span>slot <span class="token operator">=</span> slot
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>对插槽的一些处理。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// install component management hooks onto the placeholder node</span>
  <span class="token function">installComponentHooks</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
</code></pre></div><p>这儿有个比较重要的逻辑<code>installComponentHooks</code>方法，注册一些组件钩子，接下来看看<code>installComponentHooks</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">installComponentHooks</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">data</span><span class="token operator">:</span> VNodeData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hooks <span class="token operator">=</span> data<span class="token punctuation">.</span>hook <span class="token operator">||</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>hook <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hooksToMerge<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> hooksToMerge<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">const</span> existing <span class="token operator">=</span> hooks<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">const</span> toMerge <span class="token operator">=</span> componentVNodeHooks<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>existing <span class="token operator">!==</span> toMerge <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>existing <span class="token operator">&amp;&amp;</span> existing<span class="token punctuation">.</span>_merged<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      hooks<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> existing <span class="token operator">?</span> <span class="token function">mergeHook</span><span class="token punctuation">(</span>toMerge<span class="token punctuation">,</span> existing<span class="token punctuation">)</span> <span class="token operator">:</span> toMerge
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先从<code>data</code>中获取<code>hook</code>，如果没有就添加<code>hook</code>，然后遍历<code>hooksToMerge</code>，我们先来看看<code>hooksToMerge</code>是个什么</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> hooksToMerge <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>componentVNodeHooks<span class="token punctuation">)</span>
</code></pre></div><p>可以看到<code>hooksToMerge</code>是<code>componentVNodeHooks</code>对象的<code>keys</code>集合，然后我们看看<code>componentVNodeHooks</code>对象的定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// inline hooks to be invoked on component VNodes during patch</span>
<span class="token keyword">const</span> componentVNodeHooks <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">init</span> <span class="token punctuation">(</span>vnode<span class="token operator">:</span> VNodeWithData<span class="token punctuation">,</span> <span class="token literal-property property">hydrating</span><span class="token operator">:</span> boolean<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>boolean <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">prepatch</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">oldVnode</span><span class="token operator">:</span> MountedComponentVNode<span class="token punctuation">,</span> <span class="token literal-property property">vnode</span><span class="token operator">:</span> MountedComponentVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">insert</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vnode</span><span class="token operator">:</span> MountedComponentVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">destroy</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vnode</span><span class="token operator">:</span> MountedComponentVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>componentVNodeHooks</code>定义了一些<code>hook</code>钩子函数，具体功能我们之后会具体分析，我们先回到<code>installComponentHooks</code>函数中，定义<code>key = hooksToMerge[i]</code>,然后定义<code>existing</code>等于<code>hooks[key]</code>，也就是<code>data.hook[key]</code>钩子，定义<code>toMerge</code>为<code>componentVNodeHooks</code>中对应<code>key</code>的函数，如果<code>existing</code>不等于<code>toMerge且existing</code>.
<code>_merged</code>不存在时进行合并，将<code>componentVNodeHooks</code>中的钩子合并到<code>data.hook</code>中，如果<code>existing</code>存在说明存在同名函数，就执行<code>mergeHook</code>方法，否则直接等于<code>toMerge</code>就好了。然后我们看看<code>mergeHook</code>方法做了什么</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeHook</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">f1</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token literal-property property">f2</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> Function <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">merged</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// flow complains about extra args which is why we use any</span>
    <span class="token function">f1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token function">f2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  merged<span class="token punctuation">.</span>_merged <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token keyword">return</span> merged
<span class="token punctuation">}</span>
</code></pre></div><p>其实就是个简单的合并策略，就是返回一个闭包函数来依次执行传入的两个函数，同时设置<code>merged._merged</code>为<code>true</code>，说明这是个已经合并过了，上面判断<code>existing._merged</code>为<code>true</code>就不会重复合并了。
所以<code>installComponentHooks</code>方法其实就在data上注册初始化预先定义好的<code>hook</code>钩子，如果<code>data</code>上已经有了<code>hook</code>还能做一些合并处理。
继续回到<code>createComponent</code>函数中</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// return a placeholder vnode</span>
  <span class="token keyword">const</span> name <span class="token operator">=</span> Ctor<span class="token punctuation">.</span>options<span class="token punctuation">.</span>name <span class="token operator">||</span> tag
  <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-component-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Ctor<span class="token punctuation">.</span>cid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    data<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>
    <span class="token punctuation">{</span> Ctor<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>
    asyncFactory
  <span class="token punctuation">)</span>
<span class="token comment">// ...WEEX平台逻辑</span>
  <span class="token keyword">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><p>最后定义<code>name</code>为<code>Ctor.options.name</code>或<code>tag</code>，然后创建<code>vnode</code>，创建组件<code>vnode</code>时候和普通<code>vnode</code>有点不一样，<code>tag</code>参数会添加一些标识，第三四五参数都是<code>undefined</code>，这儿特别指出第三个参数<code>children</code>为<code>undefined</code>,这是不同于之前我们创建<code>vnode</code>的（一些空的<code>vnode</code>或者文本节点除外，这些<code>vnode</code>创建基本上没有什么参数），然后它有多传了第七参数<code>componentOptions</code>，虽然<code>children</code>参数为空，但是<code>componentOptions</code>中是含有<code>children</code>的。省略<code>weex</code>平台逻辑，最终返回<code>vnode</code>。
返回<code>vnode</code>之后基本上就跟我们之前流程一致了，<code>vm._render</code>函数返回<code>vnode</code>作为<code>vm._update</code>方法的第一个参数，<code>vm._update</code>函数中调用<code>patch</code>方法，最终完成组件的渲染。下一小节我们就来分析组件的<code>patch</code>方法。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./main/chapter2/2-5.html" class="prev">
        2.5 最终的挂载方法_update
      </a></span> <span class="next"><a href="/./main/chapter3/3-2.html">
        3.2 组件的patch过程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.20317d9d.js" defer></script><script src="./assets/js/2.8a65079d.js" defer></script><script src="./assets/js/10.3d2f32ec.js" defer></script>
  </body>
</html>
