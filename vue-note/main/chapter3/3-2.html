<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>3.2组件的patch过程 | 卷心菜笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="./logo.jpg">
    <meta name="description" content="基于vue@2.6.14的学习笔记">
    
    <link rel="preload" href="./assets/css/0.styles.88a4e9f5.css" as="style"><link rel="preload" href="./assets/js/app.d5acc79b.js" as="script"><link rel="preload" href="./assets/js/2.b590321b.js" as="script"><link rel="preload" href="./assets/js/26.244eb099.js" as="script"><link rel="prefetch" href="./assets/js/10.28c22c34.js"><link rel="prefetch" href="./assets/js/11.b72984a2.js"><link rel="prefetch" href="./assets/js/12.7a356702.js"><link rel="prefetch" href="./assets/js/13.4d2ebb73.js"><link rel="prefetch" href="./assets/js/14.7e5c333b.js"><link rel="prefetch" href="./assets/js/15.33ab5b85.js"><link rel="prefetch" href="./assets/js/16.26bfda56.js"><link rel="prefetch" href="./assets/js/17.f8249aae.js"><link rel="prefetch" href="./assets/js/18.8b77e49e.js"><link rel="prefetch" href="./assets/js/19.4ea26ad8.js"><link rel="prefetch" href="./assets/js/20.5c1ea347.js"><link rel="prefetch" href="./assets/js/21.439ae5de.js"><link rel="prefetch" href="./assets/js/22.bc9ba01a.js"><link rel="prefetch" href="./assets/js/23.065a389a.js"><link rel="prefetch" href="./assets/js/24.f02ba9a4.js"><link rel="prefetch" href="./assets/js/25.dc260f1b.js"><link rel="prefetch" href="./assets/js/27.e697ae03.js"><link rel="prefetch" href="./assets/js/28.a44f6cb5.js"><link rel="prefetch" href="./assets/js/29.a2c96871.js"><link rel="prefetch" href="./assets/js/3.609c0cd5.js"><link rel="prefetch" href="./assets/js/30.6bee233a.js"><link rel="prefetch" href="./assets/js/31.526a0347.js"><link rel="prefetch" href="./assets/js/32.ec625040.js"><link rel="prefetch" href="./assets/js/33.176d019f.js"><link rel="prefetch" href="./assets/js/34.f8e99996.js"><link rel="prefetch" href="./assets/js/35.99d9ab20.js"><link rel="prefetch" href="./assets/js/36.3ac859f6.js"><link rel="prefetch" href="./assets/js/37.56c9e9af.js"><link rel="prefetch" href="./assets/js/38.79ffb3a9.js"><link rel="prefetch" href="./assets/js/39.78873087.js"><link rel="prefetch" href="./assets/js/4.8492e10d.js"><link rel="prefetch" href="./assets/js/40.090b8936.js"><link rel="prefetch" href="./assets/js/41.aff618f5.js"><link rel="prefetch" href="./assets/js/42.b7419902.js"><link rel="prefetch" href="./assets/js/43.08762476.js"><link rel="prefetch" href="./assets/js/44.c271147a.js"><link rel="prefetch" href="./assets/js/45.e3aa209f.js"><link rel="prefetch" href="./assets/js/46.e9f719cf.js"><link rel="prefetch" href="./assets/js/47.9dbe7a9c.js"><link rel="prefetch" href="./assets/js/48.6d4f4e24.js"><link rel="prefetch" href="./assets/js/49.d8c44484.js"><link rel="prefetch" href="./assets/js/5.9754c995.js"><link rel="prefetch" href="./assets/js/50.06915873.js"><link rel="prefetch" href="./assets/js/51.95bc78ef.js"><link rel="prefetch" href="./assets/js/52.1bb1ed2a.js"><link rel="prefetch" href="./assets/js/53.85e86e9e.js"><link rel="prefetch" href="./assets/js/54.09fdaeea.js"><link rel="prefetch" href="./assets/js/55.d4016f45.js"><link rel="prefetch" href="./assets/js/56.dba7b1b2.js"><link rel="prefetch" href="./assets/js/57.9dde0f1c.js"><link rel="prefetch" href="./assets/js/58.72119fb4.js"><link rel="prefetch" href="./assets/js/59.487cd045.js"><link rel="prefetch" href="./assets/js/6.e61ed567.js"><link rel="prefetch" href="./assets/js/60.0d871d2d.js"><link rel="prefetch" href="./assets/js/61.533b4fa7.js"><link rel="prefetch" href="./assets/js/62.aaa2503f.js"><link rel="prefetch" href="./assets/js/63.7f5805e7.js"><link rel="prefetch" href="./assets/js/64.9db1f00f.js"><link rel="prefetch" href="./assets/js/65.d081a9d0.js"><link rel="prefetch" href="./assets/js/66.e26704f9.js"><link rel="prefetch" href="./assets/js/67.3a264983.js"><link rel="prefetch" href="./assets/js/68.285e16f9.js"><link rel="prefetch" href="./assets/js/69.6c656e15.js"><link rel="prefetch" href="./assets/js/7.2adcf0d8.js"><link rel="prefetch" href="./assets/js/70.8579a645.js"><link rel="prefetch" href="./assets/js/71.45029e1d.js"><link rel="prefetch" href="./assets/js/72.d94d691b.js"><link rel="prefetch" href="./assets/js/73.4b07003f.js"><link rel="prefetch" href="./assets/js/74.360630d3.js"><link rel="prefetch" href="./assets/js/75.fbb3c111.js"><link rel="prefetch" href="./assets/js/76.cc64c3e2.js"><link rel="prefetch" href="./assets/js/77.31e5cc90.js"><link rel="prefetch" href="./assets/js/78.acb73a36.js"><link rel="prefetch" href="./assets/js/79.232d6d8b.js"><link rel="prefetch" href="./assets/js/8.f23d7123.js"><link rel="prefetch" href="./assets/js/80.055408d9.js"><link rel="prefetch" href="./assets/js/81.955667b3.js"><link rel="prefetch" href="./assets/js/82.d60cdc5d.js"><link rel="prefetch" href="./assets/js/83.a5260291.js"><link rel="prefetch" href="./assets/js/84.790bfe99.js"><link rel="prefetch" href="./assets/js/85.8c50e659.js"><link rel="prefetch" href="./assets/js/86.4e4dd176.js"><link rel="prefetch" href="./assets/js/87.9c713ef2.js"><link rel="prefetch" href="./assets/js/88.1b1f4df4.js"><link rel="prefetch" href="./assets/js/89.c7c6f297.js"><link rel="prefetch" href="./assets/js/9.d5fa6ae7.js"><link rel="prefetch" href="./assets/js/90.5bfdf869.js">
    <link rel="stylesheet" href="./assets/css/0.styles.88a4e9f5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./" class="home-link router-link-active"><!----> <span class="site-name">卷心菜笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./main/" class="nav-link router-link-active">
  正文
</a></div><div class="nav-item"><a href="/./appendix/mergeOptions.html" class="nav-link">
  附录
</a></div><div class="nav-item"><a href="/./util/" class="nav-link">
  工具
</a></div><div class="nav-item"><a href="https://github.com/w781223592/vue2.0-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/./main/" aria-current="page" class="sidebar-link">前言</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 初识Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter1/1-1.html" class="sidebar-link">1.1 Vue目录设计</a></li><li><a href="/./main/chapter1/1-2.html" class="sidebar-link">1.2 Vue入口文件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 Vue初始化和挂载</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter2/2-1.html" class="sidebar-link">2.1 new Vue()时做了什么</a></li><li><a href="/./main/chapter2/2-2.html" class="sidebar-link">2.2 Vue实例挂载的实现</a></li><li><a href="/./main/chapter2/2-3.html" class="sidebar-link">2.3 Vue挂载时的mountComponent</a></li><li><a href="/./main/chapter2/2-4.html" class="sidebar-link">2.4 Virtual DOM</a></li><li><a href="/./main/chapter2/2-5.html" class="sidebar-link">2.5 最终的挂载方法_update</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第三章 组件化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter3/3-1.html" class="sidebar-link">3.1 创建组件vnode</a></li><li><a href="/./main/chapter3/3-2.html" aria-current="page" class="active sidebar-link">3.2组件的patch过程</a></li><li><a href="/./main/chapter3/3-3.html" class="sidebar-link">3.3合并配置</a></li><li><a href="/./main/chapter3/3-4.html" class="sidebar-link">3.4生命周期（上）</a></li><li><a href="/./main/chapter3/3-5.html" class="sidebar-link">3.5生命周期（下）</a></li><li><a href="/./main/chapter3/3-6.html" class="sidebar-link">3.6组件的注册</a></li><li><a href="/./main/chapter3/3-7.html" class="sidebar-link">3.7 异步组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第四章 响应式原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter4/4-1.html" class="sidebar-link">4.1 响应式对象</a></li><li><a href="/./main/chapter4/4-2.html" class="sidebar-link">4.2 依赖收集（上）</a></li><li><a href="/./main/chapter4/4-3.html" class="sidebar-link">4.3 依赖收集（下）</a></li><li><a href="/./main/chapter4/4-4.html" class="sidebar-link">4.4 派发更新</a></li><li><a href="/./main/chapter4/4-5.html" class="sidebar-link">4.5 nextTick</a></li><li><a href="/./main/chapter4/4-6.html" class="sidebar-link">4.6 检测变化的坑</a></li><li><a href="/./main/chapter4/4-7.html" class="sidebar-link">4.7 计算属性</a></li><li><a href="/./main/chapter4/4-8.html" class="sidebar-link">4.8 侦听器</a></li><li><a href="/./main/chapter4/4-9.html" class="sidebar-link">4.9 组件更新</a></li><li><a href="/./main/chapter4/4-10.html" class="sidebar-link">4.10 diff算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 编译</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter5/5-1.html" class="sidebar-link">5.1 初探编译器</a></li><li><a href="/./main/chapter5/5-2.html" class="sidebar-link">5.2 从入口开始</a></li><li><a href="/./main/chapter5/5-3.html" class="sidebar-link">5.3 parse之解析模板（上）</a></li><li><a href="/./main/chapter5/5-4.html" class="sidebar-link">5.4 parse之解析模板（下）</a></li><li><a href="/./main/chapter5/5-5.html" class="sidebar-link">5.5 parse之生成AST（1）</a></li><li><a href="/./main/chapter5/5-6.html" class="sidebar-link">5.6 parse之生成AST（2）</a></li><li><a href="/./main/chapter5/5-7.html" class="sidebar-link">5.7 parse之生成AST（3）</a></li><li><a href="/./main/chapter5/5-8.html" class="sidebar-link">5.8 parse之生成AST（4）</a></li><li><a href="/./main/chapter5/5-9.html" class="sidebar-link">5.9 parse之生成AST（5）</a></li><li><a href="/./main/chapter5/5-10.html" class="sidebar-link">5.10 optimize优化</a></li><li><a href="/./main/chapter5/5-11.html" class="sidebar-link">5.11 generate代码生成（1）</a></li><li><a href="/./main/chapter5/5-12.html" class="sidebar-link">5.12 generate代码生成（2）</a></li><li><a href="/./main/chapter5/5-13.html" class="sidebar-link">5.11 generate代码生成（3）</a></li><li><a href="/./main/chapter5/5-14.html" class="sidebar-link">5.11 generate代码生成（4）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter6/6-1.html" class="sidebar-link">6.1 events（1）</a></li><li><a href="/./main/chapter6/6-2.html" class="sidebar-link">6.1 events（2）</a></li><li><a href="/./main/chapter6/6-3.html" class="sidebar-link">6.1 events（3）</a></li><li><a href="/./main/chapter6/6-4.html" class="sidebar-link">6.1 events（4）</a></li><li><a href="/./main/chapter6/6-5.html" class="sidebar-link">6.5 v-model（1）</a></li><li><a href="/./main/chapter6/6-6.html" class="sidebar-link">6.6 v-model（3）</a></li><li><a href="/./main/chapter6/6-7.html" class="sidebar-link">6.7v-model（3）</a></li><li><a href="/./main/chapter6/6-8.html" class="sidebar-link">6.8v-model（4）</a></li><li><a href="/./main/chapter6/6-9.html" class="sidebar-link">6.9 slot（上）</a></li><li><a href="/./main/chapter6/6-10.html" class="sidebar-link">6.10 slot（中）</a></li><li><a href="/./main/chapter6/6-11.html" class="sidebar-link">6.11 slot（下）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 内置组件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter7/7-1.html" class="sidebar-link">7.1 keep-alive（上）</a></li><li><a href="/./main/chapter7/7-2.html" class="sidebar-link">7.2 keep-alive（下）</a></li><li><a href="/./main/chapter7/7-3.html" class="sidebar-link">7.3 transition（上）</a></li><li><a href="/./main/chapter7/7-4.html" class="sidebar-link">7.4 transition（中）</a></li><li><a href="/./main/chapter7/7-5.html" class="sidebar-link">7.5 transition（下）</a></li><li><a href="/./main/chapter7/7-6.html" class="sidebar-link">7.6 transition-group</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第八章 Vue-router</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/./main/chapter8/8-1.html" class="sidebar-link">8.1 vue-router的注册</a></li><li><a href="/./main/chapter8/8-2.html" class="sidebar-link">8.2 VueRouter实例化</a></li><li><a href="/./main/chapter8/8-3.html" class="sidebar-link">8.3 动态路由</a></li><li><a href="/./main/chapter8/8-4.html" class="sidebar-link">8.4 match</a></li><li><a href="/./main/chapter8/8-5.html" class="sidebar-link">8.5 导航守卫（上）</a></li><li><a href="/./main/chapter8/8-6.html" class="sidebar-link">8.5 导航守卫（中）</a></li><li><a href="/./main/chapter8/8-7.html" class="sidebar-link">8.5 导航守卫（下）</a></li><li><a href="/./main/chapter8/8-8.html" class="sidebar-link">8.8 路径切换</a></li><li><a href="/./main/chapter8/8-9.html" class="sidebar-link">8.9 router-view组件</a></li><li><a href="/./main/chapter8/8-10.html" class="sidebar-link">8.10 router-link组件</a></li><li><a href="/./main/chapter8/8-11.html" class="sidebar-link">8.11 history模式</a></li></ul></section></li><li><a href="/./main/finish.html" class="sidebar-link">结束感言</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_3-2组件的patch过程"><a href="#_3-2组件的patch过程" class="header-anchor">#</a> 3.2组件的patch过程</h1> <p>  之前我们已经分析过了，当我们通过<code>createComponent</code>创建了组件的<code>vnode</code>之后执行一系列逻辑，最后通过<code>vm.__patch__</code>方法把<code>vnode</code>转化为真正的<code>Dom</code>节点。这个过程我们在第二章节已经分析过了，但是它是针对某一个普通的<code>vnode</code>，这一小节我们来看看组件的<code>vnode</code>有什么不同。
我们在执行<code>patch</code>（<code>patch.js</code>中的<code>patch</code>方法）逻辑时会执行<code>createElm</code>方法，其中有这样一段逻辑</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">createComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> refElm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  判断<code>createComponent()</code>不为空就<code>return</code>，我们来看看<code>patch</code>过程中<code>createComponent()</code>方法做了什么事，注意这里的<code>createComponent</code>方法与上节课的方法不是一回事。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createComponent</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> refElm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> isReactivated <span class="token operator">=</span> <span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i<span class="token punctuation">.</span>keepAlive
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>init<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">i</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* hydrating */</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// after calling the init hook, if the vnode is a child component</span>
    <span class="token comment">// it should've created a child instance and mounted it. the child</span>
    <span class="token comment">// component also has set the placeholder vnode's elm.</span>
    <span class="token comment">// in that case we can just return the element and be done.</span>
    <span class="token comment">// 在调用init hook之后，如果vnode是一个子组件，那么它应该创建一个子实例并挂载它。子组件还设置了占位符vnode的elm。在这种情况下，我们只需返回元素就可以了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">initComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
      <span class="token function">insert</span><span class="token punctuation">(</span>parentElm<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>elm<span class="token punctuation">,</span> refElm<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isTrue</span><span class="token punctuation">(</span>isReactivated<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reactivateComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">,</span> parentElm<span class="token punctuation">,</span> refElm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  首先是获取到<code>vnode.data</code>，然后判断<code>data</code>存在与否，然后定义<code>isReactivated</code>，这个变量是与<code>keepAlive</code>有关的内容，我们先不做分析，再往下我们看看<code>i</code>中有没有<code>hook</code>，<code>hook</code>中有没有<code>init</code>方法，如果有就执行<code>init()</code>方法，这里的<code>i</code>变量重复利用被赋值为<code>init</code>方法。
那么<code>init</code>方法是什么东西呢？又是在哪定义的呢？我们在上一小节分析组件<code>vnode</code>的生成是时有一段注册<code>hook</code>的方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">installComponentHooks</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
</code></pre></div><p>  就是在这个函数中注册了组件的这些钩子，也就是在<code>data.hook</code>上注册了这些hook钩子，我们接下来看看<code>init</code>方法的定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">init</span> <span class="token punctuation">(</span>vnode<span class="token operator">:</span> VNodeWithData<span class="token punctuation">,</span> <span class="token literal-property property">hydrating</span><span class="token operator">:</span> boolean<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>boolean <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">.</span>_isDestroyed <span class="token operator">&amp;&amp;</span>
    vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// kept-alive components, treat as a patch</span>
    <span class="token keyword">const</span> <span class="token literal-property property">mountedNode</span><span class="token operator">:</span> any <span class="token operator">=</span> vnode <span class="token comment">// work around flow</span>
    componentVNodeHooks<span class="token punctuation">.</span><span class="token function">prepatch</span><span class="token punctuation">(</span>mountedNode<span class="token punctuation">,</span> mountedNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>
      vnode<span class="token punctuation">,</span>
      activeInstance
    <span class="token punctuation">)</span>
    child<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>hydrating <span class="token operator">?</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  因为<code>if</code>里面是有关<code>keepAlive</code>的逻辑，所以我们直接看<code>else</code>逻辑，定义<code>child</code>并设置它和<code>vnode.componentInstance</code>为<code>createComponentInstanceForVnode()</code>，我们先来看<code>createComponentInstanceForVnode</code>方法，<code>vnode.componentInstance</code>也是在这里被赋值，在<code>new VNode</code>时实际上是赋值为<code>undefined</code>，这里我们需要注意一下，在<code>3.4</code>小节时候我们会用到。这里特别注意一下传入的第二个参数<code>activeInstance</code>，这个变量是什么我们后面会分析。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComponentInstanceForVnode</span> <span class="token punctuation">(</span>
  <span class="token comment">// we know it's MountedComponentVNode but flow doesn't</span>
  <span class="token literal-property property">vnode</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// activeInstance in lifecycle state</span>
  <span class="token literal-property property">parent</span><span class="token operator">:</span> any
<span class="token punctuation">)</span><span class="token operator">:</span> Component <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token literal-property property">options</span><span class="token operator">:</span> InternalComponentOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">_isComponent</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">_parentVnode</span><span class="token operator">:</span> vnode<span class="token punctuation">,</span>
    parent
  <span class="token punctuation">}</span>
  <span class="token comment">// check inline-template render functions</span>
  <span class="token keyword">const</span> inlineTemplate <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>inlineTemplate
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>inlineTemplate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    options<span class="token punctuation">.</span>render <span class="token operator">=</span> inlineTemplate<span class="token punctuation">.</span>render
    options<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> inlineTemplate<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">vnode<span class="token punctuation">.</span>componentOptions<span class="token punctuation">.</span>Ctor</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  该函数接收两个参数，第一个是组件<code>vnode</code>，第二个是<code>parent</code>，实际上就是当前vm实例。它首先定义<code>options</code>对象，第一个<code>_isComponent</code>属性为<code>true</code>，它肯定是作为组件的标识存在了；第二个属性<code>_parentVnode</code>为<code>vnode</code>，也就是组件<code>vnode</code>，我们可以理解为占位<code>vnode</code>，它是个占位节点；第三个属性<code>parent</code>即当前<code>vm</code>实例（相对于子组件来说它就是父vm实例，但是此时子组件还未实例化）。接下来是<code>template</code>逻辑先跳过，最后返回<code>new vnode.componentOptions.Ctor(options)</code>。</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>options中的第一个属性_isComponent为true这里要特别注意一下，后面我们会用到。</p></div> <p>那这里的vnode.componentOptions.Ctor是什么东西呢？我再来回顾一下上个小节的内容：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-component-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Ctor<span class="token punctuation">.</span>cid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    data<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>
    <span class="token punctuation">{</span> Ctor<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>
    asyncFactory
  <span class="token punctuation">)</span>
</code></pre></div><p>  在创建组件<code>vnode</code>函数最后生成组件<code>vnode</code>时候第八个参数是一个对象，它其实就是<code>vnode.componentOptions</code>对象，可以看到这个对象里是有<code>Ctor</code>的，然后再回顾一下<code>Ctor</code>是怎么来的？其实就是通过<code>Vue.extend</code>方法创建的<code>Sub</code>子构造器，那么<code>new Sub</code>时候会发生什么事呢？我们再看<code>Sub</code>构造函数的定义。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token keyword">const</span> <span class="token function-variable function">Sub</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">VueComponent</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  它在<code>new</code>的过程中执行了<code>this._init(options)</code>方法，这就又回到我们<code>Vue</code>的初始化时候执行的<code>_init</code>方法了，因为<code>Sub</code>构造器是从<code>Vue</code>继承来的，所以<code>Sub</code>跟<code>Vue</code>其实基本上是一致的，所以这儿<code>this._init(options)</code>方法的调用实际上就是在执行<code>Vue</code>的初始化方法，所以我们再回到<code>init.js</code>文件下的<code>_init()</code>的定义，可以看到在初始各个选项前先执行的<code>option</code>的合并：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// merge options 合并option</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>_isComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// optimize internal component instantiation 优化内部组件实例化</span>
    <span class="token comment">// since dynamic options merging is pretty slow, and none of the 因为动态选项合并非常慢，而且</span>
    <span class="token comment">// internal component options needs special treatment. 内部组件选项需要特殊处理</span>
    <span class="token function">initInternalComponent</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
      <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">,</span>
      options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>  首先判断的是<code>options._isComponent</code>，如果为<code>true</code>则执行的是组件的逻辑，我们上面特别标注了<code>options._isComponent</code>，所以这里会执行<code>initInternalComponent</code>方法。
这个方法也是定义在<code>init.js</code>文件下的，我们接下来看看它做了什么</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initInternalComponent</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component<span class="token punctuation">,</span> <span class="token literal-property property">options</span><span class="token operator">:</span> InternalComponentOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>options<span class="token punctuation">)</span>
  <span class="token comment">// doing this because it's faster than dynamic enumeration.</span>
<span class="token comment">// 这样做是因为它比动态枚举更快</span>
  <span class="token keyword">const</span> parentVnode <span class="token operator">=</span> options<span class="token punctuation">.</span>_parentVnode
  opts<span class="token punctuation">.</span>parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
  opts<span class="token punctuation">.</span>_parentVnode <span class="token operator">=</span> parentVnode

  <span class="token keyword">const</span> vnodeComponentOptions <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span>componentOptions
  opts<span class="token punctuation">.</span>propsData <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>propsData
  opts<span class="token punctuation">.</span>_parentListeners <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>listeners
  opts<span class="token punctuation">.</span>_renderChildren <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>children
  opts<span class="token punctuation">.</span>_componentTag <span class="token operator">=</span> vnodeComponentOptions<span class="token punctuation">.</span>tag
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    opts<span class="token punctuation">.</span>render <span class="token operator">=</span> options<span class="token punctuation">.</span>render
    opts<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> options<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  它接收了两个参数一个<code>vm</code>一个<code>options</code>，这个vm实际上就是<code>Sub</code>构造的实例，首先通过<code>Object.create</code>方法创建了一个继承自<code>vm.constructor.options</code>的对象并赋值给<code>opts</code>和<code>vm.$options</code>，然后获取到<code>options</code>上的父占位节点然后给<code>opts</code>的<code>parent</code>属性赋值为<code>options.parent</code>，<code>opts._parentVnode</code>赋值为<code>options.parentVnode</code>，也就是占位<code>vnode</code>。这两个属性都是在<code>createComponentInstanceForVnode</code>方法中定义的，回顾一下上文我们就可以看到定义<code>options</code>时候有这些属性。<code>options.parent</code>是这个子组件的父<code>vm</code>实例，这儿先特别注意一下这个属性，之后我们来说它为什么是组件的父级<code>vm</code>实例。我先接着往下看，接下来就是吧<code>parentVnode.componentOptions</code>对象中的一些属性添加到<code>opts</code>上。<br>
  那么<code>parentVnode.componentOptions</code>又是个什么东西呢？其实之前在<code>new</code> 一个子类构造器的时候已经使用过了它了
我们再来回顾一下生成组件<code>vnode</code>时候执行的方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span>
  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vue-component-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Ctor<span class="token punctuation">.</span>cid<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token string">''</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  data<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span>
  <span class="token punctuation">{</span> Ctor<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> children <span class="token punctuation">}</span><span class="token punctuation">,</span>
  asyncFactory
<span class="token punctuation">)</span>
</code></pre></div><p>  它的第<code>7</code>参数就是<code>componentoptions</code>，生成<code>vnode</code>的时候他也被添加到<code>VNode</code>中，也就是的<code>vnode.componentoptions</code>，之后<code>createComponentInstanceForVnode</code>方法接收的第一个参数就是生成的<code>vnode</code>，接着定义<code>options</code>时候又被作为它的<code>_parentVnode</code>属性，最后在<code>new Sub</code>时传入了<code>options</code>，所以我们在<code>init</code>中取到的<code>options</code>参数会有这些属性。说到这里我们其实还没真正分析到<code>initInternalComponent</code>方法做了什么事，其实它与非组件初始化逻辑类似，都是在对<code>options</code>进行合并，合并后的结果保存在<code>vm.options</code>中。最后有关<code>options.render</code>内容我们先不做分析，这是对应上面<code>inlineTemplate</code>存在时候的内容。
值得一提的是这里的<code>vm.constructor.options</code>是<code>Vue</code>的一些公共配置，比如说一些全局组件、全局指令、全局过滤器等；这些在<a href="/./appendix/mergeOptions.html">mergeOptions文档</a>中有涉及。<br>
  我继续往下看<code>init</code>时候执行了<code>initLifecycle(vm)</code>逻辑，我们来看看这个函数做了什么事，<code>initLifecycle</code>函数定义于<code>lifecycle.js</code>文件下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initLifecycle</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options

  <span class="token comment">// locate first non-abstract parent</span>
  <span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent <span class="token comment">// 定义parent引用当前组件父组件</span>
  <span class="token comment">// 如果父组件存在且子组件不是抽象的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果父组件是抽象的且父组件还存在父组件就向上寻找父组件，直到其不是抽象为止</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
    <span class="token punctuation">}</span>
    <span class="token comment">// 将子组件实例vm push到父组件的$children中</span>
    parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  vm<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parent
  vm<span class="token punctuation">.</span>$root <span class="token operator">=</span> parent <span class="token operator">?</span> parent<span class="token punctuation">.</span>$root <span class="token operator">:</span> vm
  vm<span class="token punctuation">.</span>$children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  vm<span class="token punctuation">.</span>$refs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  vm<span class="token punctuation">.</span>_watcher <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_inactive <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_directInactive <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  该函数主要功能就是对父子组件建立联系，将子组件的<code>vm</code>实例保存到父组件的<code>$children</code>中，当然要求是父子组件都不能是抽象组件。那么什么是抽象组件呢？<br>
  抽象组件有两个特点：<br>
  ①不渲染真实<code>dom</code>，比如内置组件<code>keep-alive</code>和<code>transition</code>组件；<br>
  ②不出现在父子关系路径上述逻辑是其实就是第二个特点的实现，之后就是在vm上初始化一些属性。<br>
  在这里我们又见到了<code>parent</code>，我们之前说它是父<code>vm</code>实例，它被一级一级函数调用传递下来，直到合并选项的时候挂载到<code>vm.$options</code>上，它的来源是执行<code>createComponentInstanceForVnode()</code>函数时候作为第二个参数被传入，那时它还不叫<code>parent</code>，而是<code>activeInstance</code>。这便是<code>parent</code>的源头了，我们再来看<code>activeInstance</code>的定义，它实际上也是定义在<code>lifecycle.js</code>文件下的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">let</span> <span class="token literal-property property">activeInstance</span><span class="token operator">:</span> any <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><p>  可以看到它是在全局被定义为<code>null</code>，很显然<code>null</code>不是我们想要的结果，所以我们来看看它在哪被赋值。在它定义的下面有这样一个函数定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vm</span><span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevActiveInstance <span class="token operator">=</span> activeInstance
  activeInstance <span class="token operator">=</span> vm
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    activeInstance <span class="token operator">=</span> prevActiveInstance
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  实现了一个闭包函数，返回函数将<code>activeInstance</code>设为<code>prevActiveInstance</code>，外层函数执行时，实际上是用了中间变量<code>prevActiveInstance</code>去保存<code>activeInstance</code>，然后将<code>activeInstance</code>设置为<code>vm</code>，内层函数执行却又把<code>activeInstance</code>恢复初始值，我们再来看看它的调用以便于分析为什么要这么做。<br> <code>setActiveInstance</code>方法的调用也是在<code>lifecycle.js</code>文件下，在<code>lifecycleMixin</code>方法下的<code>_update</code>方法下被调用的，我们第二章分析<code>_update</code>方法的时候是跳过组件相关逻辑直接去分析<code>__patch__</code>方法，现在我们来分析组件相关逻辑</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">vnode</span><span class="token operator">:</span> VNode<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token literal-property property">vm</span><span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">const</span> prevEl <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el
  <span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode
  <span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// initial render</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// updates</span>
    vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> 
  <span class="token function">restoreActiveInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre></div><p>  在执行<code>setActiveInstanc</code>e时候将<code>activeInstance</code>设置为<code>vm</code>，在执行完<code>patch</code>后又将其设置为初始值，下面我们来调试运行来看一下这个过程</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">'我是root'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre></div><p>  我们还是这个小例子，根组件渲染了<code>App</code>组件，<code>new Vue</code>时候执行了<code>init</code>方法进行初始化，生成跟组件<code>vm</code>实例后就结束了，至于内容挂载其实是要靠我们的<code>$mount</code>方法，在<code>init</code>中最后一段逻辑是这样的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>  当<code>vm.options.el</code>存在时才会调用挂载方法，显然首次初始化时候<code>el</code>是不存在的，所以我们在<code>new Vue()</code>后会手动调用<code>$mount</code>方法并传入挂载点<code>#app</code>。<br>
  之后流程就如我们第二章所分析的那样去执行<code>lifecycle.js</code>下的<code>mountComponent</code>方法，之后通过渲染<code>water</code>来执行<code>updateComponent</code>进而执行<code>_render</code>方法生成<code>vnode</code>，在生成<code>vnode</code>的过程中，我们调用了<code>createElement</code>进而执行了<code>createComponent</code>方法，其实就是我们本章<code>3.1</code>小节所述流程。<code>createComponent</code>方法生成组件<code>App</code>的<code>vnode</code>。所以根组件生成的<code>vnode</code>实际上是<code>App</code>的组件<code>vnode</code>，为什么父组件会生成子组件<code>vnode</code>呢？我们来想想<code>vnode</code>是什么，<code>vnode</code>是虚拟<code>dom</code>，在根组件中调用<code>render</code>函数就是去生成<code>App</code>的<code>vnode</code>，<code>App</code>组件实际上就是根组件要渲染的内容。所以Vue子组件的<code>vnode</code>实际上是父组件生成的。这可能会造成一些误解，组件生成的<code>vnode</code>可能并不是组件<code>vnode</code>，因为组件生成的<code>vnode</code>总是它的内容，只有它又包含子组件时，它才会生成组件<code>vnode</code>，那么子组件生成的<code>vnode</code>是怎么样的呢？以我们<code>App</code>组件为例，我们这么一段内容</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>  那么它生成的<code>vnode</code>其实就是个普通的div的<code>vnode</code>，而不是组件<code>vnode</code>，这是我们一定要注意的，如果思维不能转化过来的话，以后我们的分析中就会陷入很多误区。<br>
  我们再接着讲整个挂载流程，在执行完3.1小节所述流程后其实是生生了根组件的<code>vnode</code>，这时候会执行<code>vm._update()</code>方法（<code>lifecycle.js</code>下<code>updateComponent</code>方法）。进而再执行<code>vm.__patch__</code>方法，最终执行的其实就是本章开头所讲述的流程。这儿生成的是组件<code>vnode</code>所以在<code>patch</code>过程中多执行了一些方法，其中<code>createComponent()</code>方法会执行并返回<code>true</code>，根据开头所示逻辑，当该函数返回<code>true</code>时会直接<code>return</code>。我们已经知道<code>createElm</code>方法是将<code>vnode</code>转化成真实<code>dom</code>的方法，但是这里我们直接返回了，没有执行后续插入<code>dom</code>的逻辑。那岂不是说组件就没有被渲染成真实<code>dom</code>吗？答案显然不是的，所以我们可以断言组件的插入逻辑肯定是在<code>createComponent()</code>中，我们再回顾一下<code>createComponent()</code>方法，可以看到它的核心逻辑其实就是执行<code>init</code>函数，而<code>init</code>函数除了我们提到的<code>createComponentInstanceForVnode()</code>方法外还执行了另一个重要逻辑，就是<code>child.$mount()</code>方法，而<code>child</code>又是<code>createComponentInstanceForVnode()</code>返回的，所以<code>child</code>其实就是<code>Vue</code>子类构造器构造的子组件实例，也就是我们的<code>App</code>组件实例了，所以它同样有<code>$mount</code>方法，显然这就是组件实际被挂载的逻辑。代码执行到这里其实已经和普通内容的挂载没什么两样了。<br>
  讲到这里其实就跟之前的内容串起来了，上面我们抛开正题从头分析<code>Vue</code>执行过程的目的是什么呢？记得我们之前<code>createComponentInstanceForVnode()</code>的第二个参数是<code>activeInstance</code>，我们在分析时特别标注了这个东西，这个全局变量是穿插在整个<code>Vue</code>组件挂载中的东西，熟悉整个代码的执行流程才能更好的理解它。它英文意思是——活跃的实例，我们把它理解为正在激活的组件实例，或者正在更新或挂载的组件实例。它是在<code>__patch__</code>前被赋值的，而子组件会在<code>__patch__</code>过程中遇到子组件然后在实例化子组件时<code>activeInstance</code>作为子组件的父<code>vm</code>实例被传入，也只能是父组件实例，因为子组件还没有被实例化，所以这个参数被重定义为<code>parent</code>一级一级的传入，最后它被保留在子组件<code>vm.$options.parent</code>中，在子组件实例化过程中<code>vm.$options.parent</code>使子组件和父组件建立联系。为了把<code>activeInstance</code>讲清楚，我们花费大篇章节去说明组件化执行的整个流程，这不仅使我们更好的理解<code>activeInstance</code>是什么，更使我们对整个代码执行过程有了更深的理解。<br>
  最后我们再补充一些上面没提到的内容。什么是占位<code>vnode</code>？什么是渲染<code>vnode</code>？占位<code>vnode</code>并不是真的节点，只是用于占位。比如组件<code>vnode</code>就是一个占位vnode，在父组件中创建但是并不用于渲染真实节点，在<code>patch</code>过程中遇到组件<code>vnode</code>会实例化组件，再将组件中的内容转化为<code>vnode</code>最后再调用<code>patch</code>完成渲染，实际上占位节点作用就是占位，它告诉渲染器这里有个节点不能直接渲染需要做一些特别处理才能去渲染。渲染<code>vnode</code>就是真正用于渲染的<code>vnode</code>，可以转化为<code>dom</code>，它的<code>tag</code>一般是<code>html</code>元素如<code>div</code>等。<code>patch</code>插入顺序是怎样的？<code>patch</code>过程是一个深度遍历的过程，<code>js</code>是单线程的，所以<code>patch</code>方法总是遍历执行到最深处，最终体现是先插入子后插入父。<br>
  到这里我们组件的<code>patch</code>就讲解完了，下一小节我们讲解选项合并。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/./main/chapter3/3-1.html" class="prev">
        3.1 创建组件vnode
      </a></span> <span class="next"><a href="/./main/chapter3/3-3.html">
        3.3合并配置
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./assets/js/app.d5acc79b.js" defer></script><script src="./assets/js/2.b590321b.js" defer></script><script src="./assets/js/26.244eb099.js" defer></script>
  </body>
</html>
