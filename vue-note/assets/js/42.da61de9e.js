(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{331:function(t,e,a){"use strict";a.r(e);var s=a(14),v=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_4-7-计算属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-计算属性"}},[t._v("#")]),t._v(" 4.7 计算属性")]),t._v(" "),e("p",[t._v("  上一个小节我们讲解了"),e("code",[t._v("Vue")]),t._v("检测变化要注意的事项，同时也讲解数组响应式的实现，这个小节我们来讲解计算属性"),e("code",[t._v("computed")]),t._v("和侦听器"),e("code",[t._v("watch")]),t._v("。这两个属性是"),e("code",[t._v("Vue")]),t._v("的重要选项，如果对它们足够熟悉的话，你可以用它们写出十分优雅的代码，如果你对这两个选项不够了解的话，你可能会觉得这两个属性用处不大。下面我们先来看计算属性的实现。"),e("br"),t._v("\n  我们先来了解计算属性的实现，与我们前面分析响应式数据定义的"),e("code",[t._v("data")]),t._v("选项类似，计算属性的初始化也是在"),e("code",[t._v("initState")]),t._v("时进行的，这个其实之前分析时候是有提及的。在这之前我们需要先要阅读"),e("RouterLink",{attrs:{to:"/appendix/initState.html"}},[t._v("initState文档")]),t._v("中对"),e("code",[t._v("initComputed")]),t._v("的分析。接下来我们分析一下在"),e("code",[t._v("initState")]),t._v("文档中未提到的内容。"),e("br"),t._v("\n  在执行"),e("code",[t._v("initComputed")]),t._v("函数中会执行"),e("code",[t._v("defineComputed")]),t._v("方法，这个方放也是通过"),e("code",[t._v("Object.defineProperty")]),t._v("劫持对象，我们正常定义的计算属性函数会作为其"),e("code",[t._v("get")]),t._v("拦截函数，这也是我们为什么定义计算属性函数的时候必须要有"),e("code",[t._v("return")]),t._v("。\n但是我们知道计算属性也是响应式的，但是它不能直接修改自己的值，必须修改依赖项时它才会更新，显然我们定义的计算属性get没有这个能力，所以设置其get拦截时还需要做一些其他的事，这个我们之前是没有提到的。下面我就来看看"),e("code",[t._v("defineComputed")]),t._v("方法中出现的"),e("code",[t._v("createComputedGetter")]),t._v("方法，我们先来看源码：")],1),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createComputedGetter")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("key")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("computedGetter")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" watcher "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_computedWatchers "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("_computedWatchers"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("watcher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("watcher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dirty"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        watcher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("evaluate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Dep"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        watcher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("depend")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" watcher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("  可以看到这里返回了一个函数"),e("code",[t._v("computedGetter")]),t._v("，这个应该是一个标准的闭包，既然是闭包那么就会有个受保护变量了，这里没有定义变量，但是有一个参数"),e("code",[t._v("key")]),t._v("，这里巧妙的通过闭包实现对"),e("code",[t._v("key")]),t._v("的持有，因为"),e("code",[t._v("get")]),t._v("函数是没有参数的，所以这里要通过闭包来实现，否则就获取不到"),e("code",[t._v("key")]),t._v("了。"),e("br"),t._v("\n  我们来看内层函数"),e("code",[t._v("computedGetter")]),t._v("实现，如果"),e("code",[t._v("this._computedWatchers")]),t._v("存在就使"),e("code",[t._v("watcher = this._computedWatchers[key]")]),t._v("，"),e("code",[t._v("this._computedWatchers")]),t._v("是一个通过"),e("code",[t._v("Object.create(null)")]),t._v("创建的对象，所以它是存在的，"),e("code",[t._v("initState文档")]),t._v("也讲过它里面存放着就是计算属性"),e("code",[t._v("watcer")]),t._v("，所以我们接着往下看。"),e("br"),t._v("\n  如果"),e("code",[t._v("watcher")]),t._v("存在才继续往下执行，我们这里是存在的。然后如果"),e("code",[t._v("watcher.dirty")]),t._v("为"),e("code",[t._v("true")]),t._v("则执行"),e("code",[t._v("watcher.evaluate")]),t._v("方法，这个条件也是满足的，所以我们来看"),e("code",[t._v("evaluate")]),t._v("方法实现：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("evaluate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dirty "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("  这里其实是执行了"),e("code",[t._v("this.get()")]),t._v("方法，然后要把"),e("code",[t._v("dirty")]),t._v("置为"),e("code",[t._v("false")]),t._v("。这里其实稍微有些复杂，我们先继续往下分析，这里执行"),e("code",[t._v("get")]),t._v("方法时执行"),e("code",[t._v("pushTarget")]),t._v("，实际上就是把"),e("code",[t._v("Dep.target")]),t._v("赋值为当前"),e("code",[t._v("watcher")]),t._v("的过程，也就是当前计算属性"),e("code",[t._v("watcher")]),t._v("，然后就会执行"),e("code",[t._v("watcher.depend()")]),t._v("，这个过程也就是收集依赖的过程了，你是不是觉得的"),e("code",[t._v("depend")]),t._v("方法有点熟悉，因为我们依赖收集小节已经讲过了。但这可能只是错觉，我们之前讲的都是"),e("code",[t._v("dep")]),t._v("的"),e("code",[t._v("depend")]),t._v("方法，在"),e("code",[t._v("watcher")]),t._v("中也定义了同名方法，我们来看它的实现：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("depend")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("deps"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("deps"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("depend")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("  如果你没能理解依赖收集的过程，那么这里也很难理解，因为依赖收集过程是比较绕的，它涉及"),e("code",[t._v("dep")]),t._v("和"),e("code",[t._v("watcher")]),t._v("方法的相互调用所以导致理解起来可能复杂，这里需要你有一定的理解能力才能读懂这个过程，这很难靠别人完成。但是在这里我尽可能将它简单的说明白，同时我也希望你能不看下面内容自己理清楚这块设计。其实依赖收集是一个双向的过程，我们的"),e("code",[t._v("watcher")]),t._v("会收集它订阅的依赖"),e("code",[t._v("dep")]),t._v("在它的"),e("code",[t._v("dep")]),t._v("数组中，"),e("code",[t._v("dep")]),t._v("也会收集它的订阅者在它的"),e("code",[t._v("subs")]),t._v("数组中。"),e("br"),t._v("\n  这块是最难理解也是设计最巧妙的地方。首先计算属性的"),e("code",[t._v("watcher")]),t._v("必须已经收集到"),e("code",[t._v("dep")]),t._v("，这个方法才会执行，这里有两个难点需要解决。")]),t._v(" "),e("ol",[e("li",[t._v("什么时候收集的dep？")]),t._v(" "),e("li",[t._v("为什么这里已经有依赖了还要再次收集？"),e("br"),t._v("\n  首先我们来解决第一个问题，我们访问计算属性时触发"),e("code",[t._v("get")]),t._v("拦截，也就是执行上面所述的"),e("code",[t._v("computedGetter")]),t._v("方法，"),e("code",[t._v("computedGetter")]),t._v("内部执行"),e("code",[t._v("evaluate")]),t._v("方法时会调用"),e("code",[t._v("this.get")]),t._v("方法，"),e("code",[t._v("watcher")]),t._v("的ge方法首先要执行"),e("code",[t._v("pushTarget")]),t._v("，这样"),e("code",[t._v("Dep.target")]),t._v("就指向了当前计算属性"),e("code",[t._v("watcher")]),t._v("。然后会调用"),e("code",[t._v("this.getter")]),t._v("，也就是我们书写的计算属性函数，这时候我们会依赖一些响应式数据，而访问响应式数据又触发了它的"),e("code",[t._v("get")]),t._v("拦截，从而进行了依赖收集，这时候调用了"),e("code",[t._v("dep.depend")]),t._v("方法就会将"),e("code",[t._v("computed watcher")]),t._v("收集到对应"),e("code",[t._v("dep")]),t._v("中，同时"),e("code",[t._v("watcher")]),t._v("也会收集到"),e("code",[t._v("dep")]),t._v("，那这样就完成了依赖收集了，这里我们就解决了第一个问题。"),e("br"),t._v("\n  下面我们来解决第二个问题，我们先不直接分析这个问题。我们先想一想上面依赖收集完成后是不是就结束了呢？有没有结束要看收集依赖后修改数据时能不能正常更新页面，我们假如修改了计算属性依赖项数据，这时候肯定会更新计算属性返回，然后我们发现好像没有然后了。为什么这么说呢？因为我们从来没有给计算属性做响应式拦截，计算属性也不会派发更新。也就是说数据更新了但是没有更新页面，这和没有收集依赖是一样的，或者说我们依赖没有收集完全。其实如果其他地方用了这部分数据也是没有问题的，原因其实很简单，如果这些依赖项只在计算属性中使用过的话，我们当前组件的渲染"),e("code",[t._v("watcher")]),t._v("根本不会订阅这些"),e("code",[t._v("dep")]),t._v("，原因出在"),e("code",[t._v("Dep.target")]),t._v("上，不得不说"),e("code",[t._v("Dep.target")]),t._v("设计非常巧妙，它是经常变化的，但这也导致一些隐蔽的问题，比如在计算属性中访问响应式数据触发"),e("code",[t._v("get")]),t._v("拦截时，"),e("code",[t._v("Dep.target")]),t._v("是被修改为"),e("code",[t._v("computed")]),t._v(" "),e("code",[t._v("watcher")]),t._v("，而能触发页面更新的只有我们的渲染"),e("code",[t._v("watcher")]),t._v("。解决方法也是比较简单，再收集一次依赖就好了，"),e("code",[t._v("watcher.depend")]),t._v("就是做了这件事。再收集一次依赖有什么不同呢？当然也是"),e("code",[t._v("Dep.target")]),t._v("不同了，因为"),e("code",[t._v("watcher")]),t._v("的"),e("code",[t._v("get")]),t._v("方法调用结束后执行"),e("code",[t._v("popTarget")]),t._v("会将"),e("code",[t._v("Dep.target")]),t._v("重置为上一个值，也就是我们"),e("code",[t._v("渲染watcher")]),t._v("了，因为当前组件渲染更新其实都是在"),e("code",[t._v("渲染watcher")]),t._v("的"),e("code",[t._v("get")]),t._v("函数中进行的，所以对应"),e("code",[t._v("Dep.target")]),t._v("都是当前"),e("code",[t._v("渲染watcer")]),t._v("，因为计算属性调用"),e("code",[t._v("watcher.get")]),t._v("后只是会暂时修改"),e("code",[t._v("Dep.target")]),t._v("，而且执行完后立即恢复成了"),e("code",[t._v("渲染watcher")]),t._v("，所以再次收集依赖是有效的，当然这个过程会有重复收集的可能但是在"),e("code",[t._v("watcher.addDep")]),t._v("方法中的判断消灭了这种可能性。在"),e("code",[t._v("computedGetter")]),t._v("最后返回"),e("code",[t._v("watcher.value")]),t._v("也就是计算属性计算结果，这个就不展开分析了。"),e("br"),t._v("\n  关于这部分内容其实是比较新的逻辑，它在之前版本上做了很多修改，早期的"),e("code",[t._v("depend")]),t._v("也不长现在这样，所以这部分内容需要我们自己去分析理解，因为网上比较难找到最新的分析，这次修改使"),e("code",[t._v("computed")]),t._v("代码精简许多。"),e("br"),t._v("\n  到这里我们计算属性其实已经分析完了，但是我们不妨继续分析更新时会做哪些事看看有没有什么意外收获。响应式数据被修改时会调用"),e("code",[t._v("dep.notify")]),t._v("，然后会执行"),e("code",[t._v("watcher.update")]),t._v("方法")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("update")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* istanbul ignore else */")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lazy"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dirty "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sync"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("queueWatcher")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("  这里"),e("code",[t._v("this.lazy")]),t._v("为"),e("code",[t._v("true")]),t._v("，将"),e("code",[t._v("this.dirty")]),t._v("置为"),e("code",[t._v("true")]),t._v("，这里置为"),e("code",[t._v("true")]),t._v("的话就可以重新调用"),e("code",[t._v("get")]),t._v("来计算新值了。这里其实也是非常细节的，我们之前收集依赖时，"),e("code",[t._v("dep")]),t._v("先收集了"),e("code",[t._v("computed watcher")]),t._v("，然后才收集渲染"),e("code",[t._v("watcher")]),t._v("，恰巧"),e("code",[t._v("initComputed")]),t._v("也是在当前激活的组件创建其"),e("code",[t._v("渲染watcher")]),t._v("之前的，这说明计算属性的"),e("code",[t._v("id")]),t._v("要比渲染"),e("code",[t._v("watcher")]),t._v("要小，顺序正确就比较好了，这里我们调用"),e("code",[t._v("update")]),t._v("更新时将计算属性"),e("code",[t._v("watcher.get")]),t._v("限制解开，这样就能重新进行计算了，什么时候能重新计算呢？也就是"),e("code",[t._v("渲染watcher")]),t._v("执行时候，模板中如果绑定了计算属性，那就会触发计算属性的"),e("code",[t._v("get")]),t._v("函数——"),e("code",[t._v("computedGetter")]),t._v("，从而重新计算新值。"),e("br"),t._v("\n  如果你对计算属性足够了解就会知道计算属性有一个缓存机制，只有修改了计算属性值才会触发计算属性的重新计算，也就是我们写的计算属性函数重新执行。这里的重新计算是指重新执行"),e("code",[t._v("computed watcher")]),t._v("的"),e("code",[t._v("get")]),t._v("函数，因为我们写的计算属性函数是作为"),e("code",[t._v("watcher")]),t._v("的"),e("code",[t._v("getter")]),t._v("传入的，并在"),e("code",[t._v("watcher.get")]),t._v("中执行的。那么这里缓存功能是怎么实现的呢？最新版的计算属性体现的并不明显，v2.5.17前会多次触发触发渲染，在2.5.17版本后会多次触发"),e("code",[t._v("watcher.get")]),t._v("然后对比新旧值从而触发更新，我们目前分析的是v2.6.11，最新的"),e("code",[t._v("computed")]),t._v("就和上述过程相同了。它既不会过多的进行计算也不会过多的进行更新，因为它本身是不能触发更新的。"),e("br"),t._v("\n  computed不具备更新能力，而是将更新能力放到了它的依赖项上，当依赖项更新时会触发"),e("code",[t._v("dep.notify")]),t._v("去派发更新，而"),e("code",[t._v("notify")]),t._v("方法其实遍历去调用订阅它的"),e("code",[t._v("watcher")]),t._v("的"),e("code",[t._v("update")]),t._v("方法，而如果遍历到计算属性的"),e("code",[t._v("watcher")]),t._v("时将其"),e("code",[t._v("dirty")]),t._v("设置为"),e("code",[t._v("true")]),t._v("。其实"),e("code",[t._v("Vue")]),t._v("中一般不会随便起名字，"),e("code",[t._v("dirty")]),t._v("在编程中一般表示脏数据也就是，也就是过期的数据。这里表面计算属性被修改了然后被标记为"),e("code",[t._v("dirty")]),t._v("，之后就能从新计算了。再往后遍历就会执行渲染"),e("code",[t._v("watcher")]),t._v("的"),e("code",[t._v("update")]),t._v("，这时会走"),e("code",[t._v("else")]),t._v("分支执行"),e("code",[t._v("queueWatcher")]),t._v("，也就是触发组件更新的方法然后就和上面所说的一样执行计算属性"),e("code",[t._v("get")]),t._v("函数然后修正计算属性值，这时它不再是"),e("code",[t._v("dirty")]),t._v("。之后再访问它都不会重新计算了，这就实现了其缓存能力，在"),e("code",[t._v("evaluate")]),t._v("方法中将"),e("code",[t._v("this.value")]),t._v("赋值为"),e("code",[t._v("this.get")]),t._v("方法返回值，也就是说计算属性的值是在"),e("code",[t._v("watcher.value")]),t._v("中缓存的。"),e("br"),t._v("\n  本小节我们讲解了计算属性的实现，下一小节我们来分析侦听器的实现。")])])}),[],!1,null,null,null);e.default=v.exports}}]);